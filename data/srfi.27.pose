(((name . "random-integer")
  (signature lambda ((integer? n)) integer?)
  (desc . "The next integer x in {0, ..., n-1} obtained from default-random-source. Subsequent results of this procedure appear to be independent uniformly distributed over the range {0, ..., n-1}. The argument n must be a positive integer, otherwise an error is signalled."))
 ((name . "random-real")
  (signature lambda () real?)
  (desc . "The next number 0 < x < 1 obtained from default-random-source. Subsequent results of this procedure appear to be independent uniformly distributed. The numerical type of the results and the quantization of the output range depend on the implementation; refer to random-source-make-reals for details."))
 ((name . "default-random-source") 
  (signature value random-source?)
  (desc . "A random source from which random-integer and random-real have been derived using random-source-make-integers and random-source-make-reals. Note that an assignment to default-random-source does not change random or random-real; it is also strongly recommended not to assign a new value."))
 ((name . "make-random-source") 
  (signature lambda () random-source?)
  (desc . "Creates a new random source s. Implementations may accept additional, optional arguments in order to create different types of random sources. A random source created with make-random-source represents a deterministic stream of random bits generated by some form of pseudo random number generator. Each random source obtained as (make-random-source) generates the same stream of values, unless the state is modified with one of the procedures below."))
 ((name . "random-source?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "Tests if obj is a random source. Objects of type random source are distinct from all other types of objects."))
 ((name . "random-source-state-ref")
  (signature lambda ((random-source? s)) random-source-state)
  (desc . "Get the current state of a random source s. The structure of the object state depends on the implementation; the only portable use of it is as argument to random-source-state-set!. It is, however, required that a state possess an external representation."))
 ((name . "random-source-state-set!")
  (signature
   lambda
   ((random-source? s) (random-source-state state))
   undefined)
  (desc . "Set the current state of a random source s."))
 ((name . "random-source-randomize!")
  (signature lambda ((random-source? s)) undefined)
  (desc . "Makes an effort to set the state of the random source s to a truly random state. The actual quality of this randomization depends on the implementation but it can at least be assumed that the procedure sets s to a different state for each subsequent run of the Scheme system."))
 ((name . "random-source-pseudo-randomize!")
  (signature lambda ((random-source? s) (integer? i) (integer? j)) undefined)
  (desc . "Changes the state of the random source s into the initial state of the (i, j)-th independent random source, where i and j are non-negative integers. This procedure provides a mechanism to obtain a large number of independent random sources (usually all derived from the same backbone generator), indexed by two integers. In contrast to random-source-randomize!, this procedure is entirely deterministic."))
 ((name . "random-source-make-integers")
  (signature lambda ((random-source? s)) procedure?)
  (subsigs (return (lambda ((integer? n)) integer?)))
  (desc . "Obtains a procedure rand to generate random integers using the random source s. Rand takes a single argument n, which must be a positive integer, and returns the next uniformly distributed random integer from the interval {0, ..., n-1} by advancing the state of the source s.
If an application obtains and uses several generators for the same random source s, a call to any of these generators advances the state of s. Hence, the generators do not produce the same sequence of random integers each but rather share a state. This also holds for all other types of generators derived from a fixed random sources. Implementations that support concurrency make sure that the state of a generator is properly advanced."))
 ((name . "random-source-make-reals")
  (signature case-lambda 
             (((random-source? s)) procedure?)
             (((random-source? s) (real? unit)) procedure?))
  (subsigs (return (lambda () real?)))
  (desc . "Obtains a procedure rand to generate random real numbers 0 < x < 1 using the random source s. The procedure rand is called without arguments.
The optional parameter unit determines the type of numbers being produced by rand and the quantization of the output. Unit must be a number such that 0 < unit < 1. The numbers created by rand are of the same numerical type as unit and the potential output values are spaced by at most unit. One can imagine rand to create numbers as x*unit where x is a random integer in {1, ..., floor(1/unit)-1}. Note, however, that this need not be the way the values are actually created and that the actual resolution of rand can be much higher than unit. In case unit is absent it defaults to a reasonably small value (related to the width of the mantissa of an efficient number format).")))
