(((name . "make-eq-hashtable")
  (signature case-lambda 
             (() hashtable?)
             (((integer? capacity)) hashtable?)
             (((integer? capacity) ((or #f symbol?) weakness)) hashtable?))
  (tags pure)
  (desc . "Returns a newly allocated mutable hashtable that accepts arbitrary objects as keys, and compares those keys with eq?. If the capacity argument is provided and not #f, it must be an exact non-negative integer and the initial capacity of the hashtable is set to approximately capacity elements. The weakness argument, if provided, must be one of: #f, weak-key, weak-value, weak-key-and-value, ephemeral-key, ephemeral-value, and ephemeral-key-and-value, and determines the weakness or ephemeral status for the keys and values in the hashtable. All values other than #f are optional to support; the implementation should signal the user in an implementation-defined manner when an unsupported value is used."))
 ((name . "make-eqv-hashtable")
  (signature case-lambda
             (() hashtable?)
             (((integer? k)) hashtable?)
             (((integer? capacity) ((or #f symbol?) weakness)) hashtable?))
  (tags pure)
  (desc . "Returns a newly allocated mutable hashtable that accepts arbitrary objects as keys, and compares those keys with eqv?. The semantics of the optional arguments are as in make-eq-hashtable."))
 ((name . "make-hashtable")
  (signature
   case-lambda
   (((procedure? hash) (procedure? equiv)) hashtable?)
   (((procedure? hash) (procedure? equiv) (integer? capacity)) hashtable?)
   (((procedure? hash) (procedure? equiv) (integer? capacity) ((or #f symbol?) weakness)) hashtable?))
  (subsigs
   (hash (lambda (key) integer?))
   (equiv (lambda (a b) boolean?)))
  (tags pure)
  (desc . "If hash is #f and equiv is the eq? procedure, the semantics of make-eq-hashtable apply to the rest of the arguments. If hash is #f and equiv is the eqv? procedure, the semantics of make-eqv-hashtable apply to the rest of the arguments.
Otherwise, hash must be a pair of hash functions or a hash function, and and equiv must be a procedure. Equiv should accept two keys as arguments and return a single value. None of the procedures should mutate the hashtable returned by make-hashtable. The make-hashtable procedure returns a newly allocated mutable hashtable using the function(s) specified by hash as its hash function(s), and equiv as the equivalence function used to compare keys. The semantics of the remaining arguments are as in make-eq-hashtable and make-eqv-hashtable.
Implementations using a hashing strategy that involves a single hash function should ignore one of the functions in the pair when given a pair of hash functions. Implementations preferring a hashing strategy involving a pair of hash functions may automatically derive a pair of hash functions from a given single hash function.
The hash functions and equiv should behave like pure functions on the domain of keys. For example, the string-hash and string=? procedures are permissible only if all keys are strings and the contents of those strings are never changed so long as any of them continues to serve as a key in the hashtable. Furthermore, any pair of keys for which equiv returns true should be hashed to the same exact integer objects by the given hash function(s).
Note: Hashtables are allowed to cache the results of calling a hash function and equivalence function, so programs cannot rely on a hash function being called for every lookup or update. Furthermore any hashtable operation may call a hash function more than once."))
 ((name . "hashtable?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "Returns #t if obj is a hashtable, #f otherwise."))
 ((name . "hashtable-size")
  (signature lambda ((hashtable? hashtable)) integer?)
  (tags pure)
  (desc . "Returns the number of keys contained in hashtable as an exact integer object."))
 ((name . "hashtable-ref")
  (signature case-lambda 
             (((hashtable? hashtable) key) *)
             (((hashtable? hashtable) key default) *))
  (tags pure)
  (desc . "Returns the value in hashtable associated with key. If hashtable does not contain an association for key, default is returned. If hashtable does not contain an association for key and the default argument is not provided, an error should be signaled."))
 ((name . "hashtable-set!")
  (signature lambda ((hashtable? hashtable) key obj) undefined)
  (desc . "Changes hashtable to associate key with obj, adding a new association or replacing any existing association for key, and returns an unspecified value."))
 ((name . "hashtable-delete!")
  (signature lambda ((hashtable? hashtable) key) undefined)
  (desc . "Removes any association for key within hashtable and returns an unspecified value."))
 ((name . "hashtable-contains?")
  (signature lambda ((hashtable? hashtable) key) boolean?)
  (tags pure)
  (desc . "Returns #t if hashtable contains an association for key, #f otherwise."))
 ((name . "hashtable-lookup")
  (signature lambda ((hashtable? hashtable) key) (values * boolean?))
  (tags pure)
  (desc . "Returns two values: the value in hashtable associated with key or an unspecified value if there is none, and a Boolean indicating whether an association was found."))
 ((name . "hashtable-update!")
  (signature case-lambda
             (((hashtable? hashtable) key (procedure? proc)) boolean?)
             (((hashtable? hashtable) key (procedure? proc) default) boolean?))
  (subsigs (proc (lambda (value) *)))
  (desc . "Proc should accept one argument, should return a single value, and should not mutate hashtable. The hashtable-update! procedure applies proc to the value in hashtable associated with key, or to default if hashtable does not contain an association for key. The hashtable is then changed to associate key with the value returned by proc. If hashtable does not contain an association for key and the default argument is not provided, an error should be signaled. Hashtable-update! returns the value of the new association for key in hashtable."))
 ((name . "hashtable-intern!")
  (signature lambda ((hashtable? hashtable) key (procedure? default-proc)) *)
  (subsigs
    (default-proc (lambda () *)))
  (desc . "Default-proc should accept zero arguments, should return a single value, and should not mutate hashtable. The hashtable-intern! procedure returns the association for key in hashtable if there is one, otherwise it calls default-proc with zero arguments, associates its return value with key in hashtable, and returns that value."))
 ((name . "hashtable-copy")
  (signature
   case-lambda
   (((hashtable? hashtable)) hashtable?)
   (((hashtable? hashtable) (boolean? mutable)) hashtable?)
   (((hashtable? hashtable) (boolean? mutable) ((or #f symbol?) weakness)) hashtable?))
  (tags pure)
  (desc . "Returns a copy of hashtable. If the mutable argument is provided and is true, the returned hashtable is mutable; otherwise it is immutable. If the optional weakness argument is provided, it determines the weakness of the copy, otherwise the weakness attribute of hashtable is used."))
 ((name . "hashtable-clear!")
  (signature
   case-lambda
   (((hashtable? hashtable)) undefined)
   (((hashtable? hashtable) (integer? capacity)) undefined))
  (desc . "Removes all associations from hashtable and returns an unspecified value. If capacity is provided and not #f, it must be an exact non-negative integer and the current capacity of the hashtable is reset to approximately capacity elements."))
 ((name . "hashtable-empty-copy")
  (signature case-lambda
             (((hashtable? hashtable)) hashtable?)
             (((hashtable? hashtable) (integer? capacity)) hashtable?))
  (tags pure)
  (desc . "Returns a newly allocated mutable hashtable that has the same hash and equivalence functions and weakness attribute as hashtable. The capacity argument may be #t to set the initial capacity of the copy to approximately (hashtable-size hashtable) elements; otherwise the semantics of make-eq-hashtable apply to the capacity argument."))
 ((name . "hashtable-keys")
  (signature lambda ((hashtable? hashtable)) vector?)
  (tags pure)
  (desc . "Returns a vector of all keys in hashtable. The order of the vector is unspecified."))
 ((name . "hashtable-values")
  (signature lambda ((hashtable? hashtable)) vector?)
  (tags pure)
  (desc . "Returns a vector of all values in hashtable. The order of the vector is unspecified, and is not guaranteed to match the order of keys in the result of hashtable-keys."))
 ((name . "hashtable-entries")
  (signature lambda ((hashtable? hashtable)) (values vector? vector?))
  (tags pure)
  (desc . "Returns two values, a vector of the keys in hashtable, and a vector of the corresponding values."))
 ((name . "hashtable-key-list")
  (signature lambda ((hashtable? hashtable)) list?)
  (tags pure)
  (desc . "Returns a list of all keys in hashtable. The order of the list is unspecified."))
 ((name . "hashtable-value-list")
  (signature lambda ((hashtable? hashtable)) list?)
  (tags pure)
  (desc . "Returns a list of all values in hashtable. The order of the list is unspecified, and is not guaranteed to match the order of keys in the result of hashtable-key-list."))
 ((name . "hashtable-entry-list")
  (signature lambda ((hashtable? hashtable)) (values list? list?))
  (tags pure)
  (desc . "Returns two values, a list of the keys in hashtable, and a list of the corresponding values."))
 ((name . "hashtable-walk")
  (signature lambda ((hashtable? hashtable) (procedure? proc)) undefined)
  (subsigs
    (proc (lambda (key value) undefined)))
  (desc . "Proc should accept two arguments, and should not mutate hashtable. The hashtable-walk procedure applies proc once for every association in hashtable, passing it the key and value as arguments. The order in which proc is applied to the associations is unspecified. Return values of proc are ignored. Hashtable-walk returns an unspecified value."))
 ((name . "hashtable-update-all!")
  (signature lambda ((hashtable? hashtable) (procedure? proc)) undefined)
  (subsigs
    (proc (lambda (key value) *)))
  (desc . "Proc should accept two arguments, should return a single value, and should not mutate hashtable. The hashtable-update-all! procedure applies proc once for every association in hashtable, passing it the key and value as arguments, and changes the value of the association to the return value of proc. The order in which proc is applied to the associations is unspecified. Hashtable-update-all! returns an unspecified value."))
 ((name . "hashtable-prune!")
  (signature lambda ((hashtable? hashtable) (procedure? proc)) undefined)
  (subsigs
    (proc (lambda (key value) boolean?)))
  (desc . "Proc should accept two arguments, should return a single value, and should not mutate hashtable. The hashtable-prune! procedure applies proc once for every association in hashtable, passing it the key and value as arguments, and deletes the association if proc returns a true value. The order in which proc is applied to the associations is unspecified. Hashtable-prune! returns an unspecified value."))
 ((name . "hashtable-merge!")
  (signature lambda ((hashtable? hashtable-dest) (hashtable? hashtable-source)) hashtable?)
  (desc . "
Effectively equivalent to:
(begin
  (hashtable-walk hashtable-source
    (lambda (key value)
      (hashtable-set! hashtable-dest key value)))
  hashtable-dest)"))
 ((name . "hashtable-sum")
  (signature lambda ((hashtable? hashtable) init (procedure? proc)) *)
  (subsigs
    (proc (lambda (key value state) *)))
  (tags pure)
  (desc . "Proc should accept three arguments, should return a single value, and should not mutate hashtable. The hashtable-sum procedure accumulates a result by applying proc once for every association in hashtable, passing it as arguments: the key, the value, and the result of the previous application or init at the first application. The order in which proc is applied to the associations is unspecified."))
 ((name . "hashtable-map->lset")
  (signature lambda ((hashtable? hashtable) (procedure? proc)) list?)
  (subsigs
    (proc (lambda (key value) *)))
  (tags pure)
  (desc . "Proc should accept two arguments, should return a single value, and should not mutate hashtable. The hashtable-map->lset procedure applies proc once for every association in hashtable, passing it the key and value as arguments, and accumulates the returned values into a list. The order in which proc is applied to the associations, and the order of the results in the returned list, are unspecified."))
 ((name . "hashtable-find")
  (signature lambda ((hashtable? hashtable) (procedure? proc)) (values * * boolean?))
  (subsigs
    (proc (lambda (key value) boolean?)))
  (tags pure)
  (desc . "Proc should accept two arguments, should return a single value, and should not mutate hashtable. The hashtable-find procedure applies proc to associations in hashtable in an unspecified order until one of the applications returns a true value or the associations are exhausted. Three values are returned: the key and value of the matching association or two unspecified values if none matched, and a Boolean indicating whether any association matched."))
 ((name . "hashtable-empty?")
  (signature lambda ((hashtable? hashtable)) boolean?)
  (tags pure)
  (desc . "Effectively equivalent to:
(zero? (hashtable-size hashtable))"))
 ((name . "hashtable-pop!")
  (signature lambda ((hashtable? hashtable)) *)
  (desc . "Effectively equivalent to:
(let-values (((key value found?)
              (hashtable-find hashtable (lambda (k v) #t))))
  (when (not found?)
    (error))
  (hashtable-delete! hashtable key)
  (values key value))"))
 ((name . "hashtable-inc!")
  (signature case-lambda 
             (((hashtable? hashtable) key) boolean?)
             (((hashtable? hashtable) key (number? number)) boolean?))
  (desc . "Effectively equivalent to:
(hashtable-update! hashtable key (lambda (v) (+ v number)) 0)

where number is 1 when not provided."))
 ((name . "hashtable-dec!")
  (signature case-lambda 
             (((hashtable? hashtable) key) boolean?)
             (((hashtable? hashtable) key (number? number)) boolean?))
  (desc . "Effectively equivalent to:
(hashtable-update! hashtable key (lambda (v) (- v number)) 0)

where number is 1 when not provided."))
 ((name . "hashtable-equivalence-function")
  (signature lambda ((hashtable? hashtable)) procedure?)
  (subsigs
    (return (lambda (a b) boolean?)))
  (tags pure)
  (desc . "Returns the equivalence function used by hashtable to compare keys. For hashtables created with make-eq-hashtable and make-eqv-hashtable, returns eq? and eqv? respectively."))
 ((name . "hashtable-hash-function")
  (signature lambda ((hashtable? hashtable)) procedure?)
  (subsigs
    (return (lambda (key) integer?)))
  (tags pure)
  (desc . "Returns the hash function(s) used by hashtable, that is, either a procedure, or a pair of procedures. For hashtables created by make-eq-hashtable or make-eqv-hashtable, #f is returned."))
 ((name . "hashtable-weakness")
  (signature lambda ((hashtable? hashtable)) (or #f sybmol?))
  (tags pure)
  (desc . "Returns the weakness attribute of hashtable. The same values that are accepted as the weakness argument in the constructor procedures are returned. This procedure may expose the fact that weak-key and weak-value hashtables are implemented as ephemeral-key and ephemeral-value hashtables, returning symbols indicating the latter even when the former were used to construct the hashtable."))
 ((name . "hashtable-mutable?")
  (signature lambda ((hashtable? hashtable)) boolean?)
  (tags pure)
  (desc . "Returns #t if hashtable is mutable, otherwise #f."))
 ((name . "hash-salt")
  (signature syntax-rules ()
             ((_) integer?))
  (desc . "Expands to a form evaluating to an exact non-negative integer that lies within the fixnum range of the implementation. The value the expanded form evaluates to remains constant throughout the execution of the program. It is random for every run of the program, except when the environment variable SRFI_126_HASH_SEED is set to a non-empty string before program startup, in which case it is derived from the value of that environment variable in a deterministic manner."))
 ((name . "equal-hash") 
  (signature lambda (obj) integer?)
  (tags pure)
  (desc . "Returns an integer hash value for obj, based on its structure and current contents. This hash function is suitable for use with equal? as an equivalence function."))
 ((name . "string-hash")
  (signature lambda ((string? string)) integer?)
  (tags pure)
  (desc . "Returns an integer hash value for string, based on its current contents. This hash function is suitable for use with string=? as an equivalence function."))
 ((name . "string-ci-hash")
  (signature lambda ((string? string)) integer?)
  (tags pure)
  (desc . "Returns an integer hash value for string based on its current contents, ignoring case. This hash function is suitable for use with string-ci=? as an equivalence function."))
 ((name . "symbol-hash")
  (signature lambda ((symbol? symbol)) integer?)
  (tags pure)
  (desc . "Returns an integer hash value for symbol.")))
