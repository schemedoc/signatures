(((name . "make-enumeration")
  (signature lambda ((list? symbol-list)) enum-set)
  (tags pure)
  (desc . "Symbol-list must be a list of symbols. The make-enumeration procedure creates a new enumeration type whose universe consists of those symbols (in canonical order of their first appearance in the list) and returns that universe as an enumeration set whose universe is itself and whose enumeration type is the newly created enumeration type."))
 ((name . "enum-set-universe")
  (signature lambda ((enum-set enum-set)) enum-set)
  (tags pure)
  (desc . "Returns the set of all symbols that comprise the universe of its argument, as an enumeration set."))
 ((name . "enum-set-indexer")
  (signature lambda ((enum-set enum-set)) procedure?)
  (subsigs (return (lambda ((symbol? el)) (or #f integer?))))
  (tags pure)
  (desc . "Returns a unary procedure that, given a symbol that is in the universe of enum-set, returns its 0-origin index within the canonical ordering of the symbols in the universe; given a value not in the universe, the unary procedure returns #f."))
 ((name . "enum-set-constructor")
  (signature
   case-lambda
   (((enum-set enum-set)) procedure?)
   (((enum-set enum-set)) procedure?))
  (subsigs (return (lambda ((list? elements)) enum-set)))
  (tags pure)
  (desc . "Returns a unary procedure that, given a list of symbols that belong to the universe of enum-set, returns a subset of that universe that contains exactly the symbols in the list. The values in the list must all belong to the universe."))
 ((name . "enum-set->list")
  (signature lambda ((enum-set enum-set)) list?)
  (tags pure)
  (desc . "Returns a list of the symbols that belong to its argument, in the canonical order of the universe of enum-set."))
 ((name . "enum-set-member?")
  (signature lambda ((symbol? element) (enum-set enum-set)) boolean?)
  (tags pure)
  (desc . "The enum-set-member? procedure returns #t if its first argument is an element of its second argument, #f otherwise."))
 ((name . "enum-set-subset?")
  (signature lambda ((enum-set set1) (enum-set set2)) boolean?)
  (tags pure)
  (desc . "The enum-set-subset? procedure returns #t if the universe of enum-set1 is a subset of the universe of enum-set2 (considered as sets of symbols) and every element of enum-set1 is a member of enum-set2. It returns #f otherwise."))
 ((name . "enum-set=?")
  (signature lambda ((enum-set set1) (enum-set set2)) boolean?)
  (tags pure)
  (desc . "The enum-set=? procedure returns #t if enum-set1 is a subset of enum-set2 and vice versa, as determined by the enum-set-subset? procedure. This implies that the universes of the two sets are equal as sets of symbols, but does not imply that they are equal as enumeration types. Otherwise, #f is returned."))
 ((name . "enum-set-union")
  (signature lambda ((enum-set set1) (enum-set set2)) enum-set)
  (tags pure)
  (desc . "The enum-set-union procedure returns the union of enum-set1 and enum-set2."))
 ((name . "enum-set-intersection")
  (signature lambda ((enum-set set1) (enum-set set2)) enum-set)
  (tags pure)
  (desc . "The enum-set-intersection procedure returns the intersection of enum-set1 and enum-set2."))
 ((name . "enum-set-difference")
  (signature lambda ((enum-set set1) (enum-set set2)) enum-set)
  (tags pure)
  (desc . "The enum-set-difference procedure returns the difference of enum-set1 and enum-set2."))
 ((name . "enum-set-complement")
  (signature lambda ((enum-set set)) enum-set)
  (tags pure)
  (desc . "Returns enum-set's complement with respect to its universe."))
 ((name . "enum-set-projection")
  (signature lambda ((enum-set set1) (enum-set set2)) enum-set)
  (tags pure)
  (desc . "Projects enum-set1 into the universe of enum-set2, dropping any elements of enum-set1 that do not belong to the universe of enum-set2. (If enum-set1 is a subset of the universe of its second, no elements are dropped, and the injection is returned.)"))
 ((name . "define-enumeration")
  (signature syntax-rules () ((_ type-name (symbol ...) constructor-syntax)))
  (desc . "The define-enumeration form defines an enumeration type and provides two macros for constructing its members and sets of its members. A define-enumeration form is a definition and can appear anywhere any other <definition> can appear. <Type-name> is an identifier that is bound as a syntactic keyword; <symbol> ... are the symbols that comprise the universe of the enumeration (in order). (<type-name> <symbol>) checks at macro-expansion time whether the name of <symbol> is in the universe associated with <type-name>. If it is, (<type-name> <symbol>) is equivalent to <symbol>. It is a syntax violation if it is not. <Constructor-syntax> is an identifier that is bound to a macro that, given any finite sequence of the symbols in the universe, possibly with duplicates, expands into an expression that evaluates to the enumeration set of those symbols. (<constructor-syntax> <symbol> ...) checks at macro-expansion time whether every <symbol> ... is in the universe associated with <type-name>. It is a syntax violation if one or more is not. Otherwise (<constructor-syntax> <symbol> ...) is equivalent to ((enum-set-constructor (<constructor-syntax>)) '(<symbol> ...)).")))
