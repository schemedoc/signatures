(((name . "make-list-queue")
  (signature
   case-lambda
   (((list? list)) list-queue?)
   (((list? list) (pair? last)) list-queue?))
  (tags pure)
  (desc . "Returns a newly allocated list queue containing the elements of list in order. The result shares storage with list. If the last argument is not provided, this operation is O(n) where n is the length of list.
However, if last is provided, make-list-queue returns a newly allocated list queue containing the elements of the list whose first pair is first and whose last pair is last. It is an error if the pairs do not belong to the same list. Alternatively, both first and last can be the empty list. In either case, the operation is O(1).
Note: To apply a non-destructive list procedure to a list queue and return a new list queue, use (make-list-queue (proc (list-queue-list list-queue)))."))
 ((name . "list-queue")
  (signature
   case-lambda
   ((element ...) list-queue?)
   (((list-queue? list-queue)) list-queue?))
  (tags pure)
  (desc . "Returns a newly allocated list queue containing the elements. This operation is O(n) where n is the number of elements."))
 ((name . "list-queue-copy")
  (signature lambda ((list-queue? list-queue)) list-queue?)
  (tags pure)
  (desc . "Returns a newly allocated list queue containing the elements of list-queue. This operation is O(n) where n is the length of list-queue"))
 ((name . "list-queue-unfold")
  (signature
   case-lambda
   (((procedure? stop?) (procedure? mapper) (procedure? successor) seed)
    list-queue?)
   (((procedure? stop?)
     (procedure? mapper)
     (procedure? successor)
     seed
     (list-queue? queue))
    list-queue?))
  (subsigs
   (stop? (lambda (seed) boolean?))
   (mapper (lambda (seed) *))
   (successor (lambda (seed) *)))
  (tags pure)
  (desc . "Performs the following algorithm:
If the result of applying the predicate stop? to seed is true, return queue. Otherwise, apply the procedure mapper to seed, returning a value which is added to the front of queue. Then get a new seed by applying the procedure successor to seed, and repeat this algorithm.
If queue is omitted, a newly allocated list queue is used."))
 ((name . "list-queue-unfold-right")
  (signature
   case-lambda
   (((procedure? stop?) (procedure? mapper) (procedure? successor) seed)
    list-queue?)
   (((procedure? stop?)
     (procedure? mapper)
     (procedure? successor)
     seed
     (list-queue? queue))
    list-queue?))
  (subsigs
   (stop? (lambda (seed) boolean?))
   (mapper (lambda (seed) *))
   (successor (lambda (seed) *)))
  (tags pure)
  (desc . "Performs the following algorithm:
If the result of applying the predicate stop? to seed is true, return the list queue. Otherwise, apply the procedure mapper to seed, returning a value which is added to the back of the list queue. Then get a new seed by applying the procedure successor to seed, and repeat this algorithm.
If queue is omitted, a newly allocated list queue is used."))
 ((name . "list-queue?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "Returns #t if obj is a list queue, and #f otherwise. This operation is O(1)."))
 ((name . "list-queue-empty?")
  (signature lambda ((list-queue? list-queue)) boolean?)
  (tags pure)
  (desc . "Returns #t if list-queue has no elements, and #f otherwise. This operation is O(1)."))
 ((name . "list-queue-front")
  (signature lambda ((list-queue? list-queue)) *)
  (tags pure)
  (desc . "Returns the first element of list-queue. If the list queue is empty, it is an error. This operation is O(1)."))
 ((name . "list-queue-back")
  (signature lambda ((list-queue? list-queue)) *)
  (tags pure)
  (desc . "Returns the last element of list-queue. If the list queue is empty, it is an error. This operation is O(1)."))
 ((name . "list-queue-list")
  (signature lambda ((list-queue? list-queue)) list?)
  (tags pure)
  (desc . "Returns the list that contains the members of list-queue in order. The result shares storage with list-queue. This operation is O(1)."))
 ((name . "list-queue-first-last")
  (signature lambda ((list-queue? list-queue)) (values list? list?))
  (tags pure)
  (desc . "Returns two values, the first and last pairs of the list that contains the members of list-queue in order. If list-queue is empty, returns two empty lists. The results share storage with list-queue. This operation is O(1)."))
 ((name . "list-queue-add-front!")
  (signature lambda ((list-queue? list-queue) element) undefined)
  (desc . "Adds element to the beginning of list-queue. Returns an unspecified value. This operation is O(1)."))
 ((name . "list-queue-add-back!")
  (signature lambda ((list-queue? list-queue) element) undefined)
  (desc . "Adds element to the end of list-queue. Returns an unspecified value. This operation is O(1)."))
 ((name . "list-queue-remove-front!")
  (signature lambda ((list-queue? list-queue)) *)
  (desc . "Removes the first element of list-queue and returns it. If the list queue is empty, it is an error. This operation is O(1)."))
 ((name . "list-queue-remove-back!")
  (signature lambda ((list-queue? list-queue)) *)
  (desc . "Removes the last element of list-queue and returns it. If the list queue is empty, it is an error. This operation is O(n) where n is the length of list-queue, because queues do not not have backward links."))
 ((name . "list-queue-remove-all!")
  (signature lambda ((list-queue? list-queue)) list?)
  (desc . "Removes all the elements of list-queue and returns them in order as a list. This operation is O(1)."))
 ((name . "list-queue-set-list!")
  (signature
   case-lambda
   (((list-queue? list-queue) (list? list)) undefined)
   (((list-queue? list-queue) (list? list) (pair? last)) undefined))
  (desc . "Replaces the list associated with list-queue with list, effectively discarding all the elements of list-queue in favor of those in list. Returns an unspecified value. This operation is O(n) where n is the length of list. If last is provided, it is treated in the same way as in make-list-queue, and the operation is O(1).
Note: To apply a destructive list procedure to a list queue, use (list-queue-set-list! (proc (list-queue-list list-queue)))."))
 ((name . "list-queue-append")
  (signature lambda ((list-queue? list-queue) ...) list-queue?)
  (tags pure)
  (desc . "Returns a list queue which contains all the elements in front-to-back order from all the list-queues in front-to-back order. The result does not share storage with any of the arguments. This operation is O(n) in the total number of elements in all queues."))
 ((name . "list-queue-append!")
  (signature lambda ((list-queue? list-queue) ...) list-queue?)
  (desc . "Returns a list queue which contains all the elements in front-to-back order from all the list-queues in front-to-back order. It is an error to assume anything about the contents of the list-queues after the procedure returns. This operation is O(n) in the total number of queues, not elements. It is not part of the R7RS-small list API, but is included here for efficiency when pure functional append is not required."))
 ((name . "list-queue-concatenate")
  (signature lambda ((list? list-of-list-queues)) list-queue?)
  (tags pure)
  (desc . "Returns a list queue which contains all the elements in front-to-back order from all the list queues which are members of list-of-list-queues in front-to-back order. The result does not share storage with any of the arguments. This operation is O(n) in the total number of elements in all queues. It is not part of the R7RS-small list API, but is included here to make appending a large number of queues possible in Schemes that limit the number of arguments to apply."))
 ((name . "list-queue-map")
  (signature lambda ((procedure? proc) (list-queue? list-queue)) list-queue?)
  (subsigs (proc (lambda (element) *)))
  (tags pure)
  (desc . "Applies proc to each element of list-queue in unspecified order and returns a newly allocated list queue containing the results. This operation is O(n) where n is the length of list-queue."))
 ((name . "list-queue-map!")
  (signature lambda ((procedure? proc) (list-queue? list-queue)) undefined)
  (subsigs (proc (lambda (element) *)))
  (desc . "Applies proc to each element of list-queue in front-to-back order and modifies list-queue to contain the results. This operation is O(n) in the length of list-queue. It is not part of the R7RS-small list API, but is included here to make transformation of a list queue by mutation more efficient."))
 ((name . "list-queue-for-each")
  (signature lambda ((procedure? proc) (list-queue? list-queue)) undefined)
  (subsigs (proc (lambda (element) undefined)))
  (desc . "Applies proc to each element of list-queue in front-to-back order, discarding the returned values. Returns an unspecified value. This operation is O(n) where n is the length of list-queue.")))
