(((name . "find")
  (signature lambda ((procedure? pred) (list? list)) *)
  (subsigs (pred (lambda (obj) *)))
  (tags pure)
  (desc . "Proc should accept one argument and return a single value. Proc should not mutate list. The find procedure applies proc to the elements of list in order. If proc returns a true value for an element, find immediately returns that element. If proc returns #f for all elements of the list, find returns #f. Proc is always called in the same dynamic environment as find itself."))
 ((name . "for-all")
  (signature lambda ((procedure? pred) (list? list1) (list? list2) ...) *)
  (subsigs (pred (lambda (obj1 obj2 ...) *)))
  (tags pure)
  (desc . "The lists should all have the same length, and proc should accept n arguments and return a single value. Proc should not mutate the list arguments. For natural numbers i = 0, 1, ..., the for-all procedure successively applies proc to arguments xi1 ... xin, where xij is the ith element of listj, until #f is returned. If proc returns true values for all but the last element of list1, for-all performs a tail call of proc on the kth elements, where k is the length of list1. If proc returns #f on any set of elements, for-all returns #f after the first such application of proc. If the lists are all empty, for-all returns #t."))
 ((name . "exists")
  (signature lambda ((procedure? pred) (list? list1) (list? list2) ...) *)
  (subsigs (pred (lambda (obj1 obj2 ...) *)))
  (tags pure)
  (desc . " The lists should all have the same length, and proc should accept n arguments and return a single value. Proc should not mutate the list arguments. For natural numbers i = 0, 1, ..., the exists procedure applies proc successively to arguments xi1 ... xin, where xij is the ith element of listj, until a true value is returned. If proc returns #f for all but the last elements of the lists, exists performs a tail call of proc on the kth elements, where k is the length of list1. If proc returns a true value on any set of elements, exists returns that value after the first such application of proc. If the lists are all empty, exists returns #f."))
 ((name . "filter")
  (signature lambda ((procedure? pred) (list? list)) list?)
  (subsigs (pred (lambda (obj) *)))
  (tags pure)
  (desc . "Proc should accept one argument and return a single value. Proc should not mutate list. The filter procedure applies proc to each element of list and returns a list of the elements of list for which proc returned a true value. The elements of the result list are in the same order as they appear in the input list. Proc is always called in the same dynamic environment as filter. If multiple returns occur from filter, the return values returned by earlier returns are not mutated."))
 ((name . "partition")
  (signature lambda ((procedure? pred) (list? list)) (values list? list?))
  (subsigs (pred (lambda (obj) *)))
  (tags pure)
  (desc . "Proc should accept one argument and return a single value. Proc should not mutate list. The partition procedure also applies proc to each element of list, but returns two values, the first one a list of the elements of list for which proc returned a true value, and the second a list of the elements of list for which proc returned #f. The elements of the result lists are in the same order as they appear in the input list. Proc is always called in the same dynamic environment as partition itself. If multiple returns occur from partitions, the return values returned by earlier returns are not mutated."))
 ((name . "fold-left")
  (signature lambda ((procedure? kons) knil (list? list1) (list? list2) ...) *)
  (subsigs (kons (lambda (obj1 obj2 ... fold-state) *)))
  (tags pure)
  (desc . "The lists should all have the same length. Combine must be a procedure. It should accept one more argument than there are lists and return a single value. It should not mutate the list arguments. The fold-left procedure iterates the combine procedure over an accumulator value and the elements of the lists from left to right, starting with an accumulator value of nil. More specifically, fold-left returns nil if the lists are empty. If they are not empty, combine is first applied to nil and the respective first elements of the lists in order. The result becomes the new accumulator value, and combine is applied to the new accumulator value and the respective next elements of the list. This step is repeated until the end of the list is reached; then the accumulator value is returned. Combine is always called in the same dynamic environment as fold-left itself."))
 ((name . "fold-right")
  (signature lambda ((procedure? kons) knil (list? list1) (list? list2) ...) *)
  (subsigs (kons (lambda (obj1 obj2 ... fold-state) *)))
  (tags pure)
  (desc . "The lists should all have the same length. Combine must be a procedure. It should accept one more argument than there are lists and return a single value. Combine should not mutate the list arguments. The fold-right procedure iterates the combine procedure over the elements of the lists from right to left and an accumulator value, starting with an accumulator value of nil. More specifically, fold-right returns nil if the lists are empty. If they are not empty, combine is first applied to the respective last elements of the lists in order and nil. The result becomes the new accumulator value, and combine is applied to the respective previous elements of the lists and the new accumulator value. This step is repeated until the beginning of the list is reached; then the accumulator value is returned. Proc is always called in the same dynamic environment as fold-right itself."))
 ((name . "remp")
  (signature lambda ((procedure? pred) (list? list)) list?)
  (subsigs (pred (lambda (obj) *)))
  (tags pure)
  (desc . "The remp procedure applies proc to each element of list and returns a list of the elements of list for which proc returned #f."))
 ((name . "remove") 
  (signature lambda (obj (list? list)) list?)
  (tags pure)
  (desc . "The remove procedure return a list of the elements that are not obj as according to equal?."))
 ((name . "remv")
  (signature lambda (obj (list? list)) list?)
  (tags pure)
  (desc . "The remv procedure return a list of the elements that are not obj as according to eqv?."))
 ((name . "remq")
  (signature lambda (obj (list? list)) list?)
  (tags pure)
  (desc . "The remq procedure return a list of the elements that are not obj as according to eq?."))
 ((name . "memp")
  (signature lambda ((procedure? pred) (list? list)) (or #f list?))
  (subsigs (pred (lambda (obj) *)))
  (tags pure)
  (desc . "Proc should accept one argument and return a single value. Proc should not mutate list. Returns the first sublist of list whose car satisfies a given condition, where the sublists of lists are the lists returned by (list-tail list k) for k less than the length of list. The memp procedure applies proc to the cars of the sublists of list until it finds one for which proc returns a true value. Proc is always called in the same dynamic environment as memp itself. If list does not contain an element satisfying the condition, then #f (not the empty list) is returned."))
 ((name . "member")
  (signature lambda (obj (list? list)) (or #f list?))
  (tags pure)
  (desc . "Returns the first sublist of list whose car satisfies a given condition, where the sublists of lists are the lists returned by (list-tail list k) for k less than the length of list. The member procedure looks for the first occurrence of obj. If list does not contain an element satisfying the condition, then #f (not the empty list) is returned. The member procedure uses equal? to compare obj with the elements of list."))
 ((name . "memq")
  (signature lambda (obj (list? list)) (or #f list?))
  (tags pure)
  (desc . "Returns the first sublist of list whose car satisfies a given condition, where the sublists of lists are the lists returned by (list-tail list k) for k less than the length of list. The memq procedure looks for the first occurrence of obj. If list does not contain an element satisfying the condition, then #f (not the empty list) is returned. The memq procedure uses eq? to compare obj with the elements of list."))
 ((name . "memv")
  (signature lambda (obj (list? list)) (or #f list?))
  (tags pure)
  (desc . "Returns the first sublist of list whose car satisfies a given condition, where the sublists of lists are the lists returned by (list-tail list k) for k less than the length of list. The memv procedure looks for the first occurrence of obj. If list does not contain an element satisfying the condition, then #f (not the empty list) is returned. The memv procedure uses eqv? to compare obj with the elements of list."))
 ((name . "assp")
  (signature lambda ((procedure? pred) (list? alist)) (or pair? #f))
  (subsigs 
    (pred (lambda (obj) *))
    (alist (alist key value)))
  (tags pure)
  (desc . "Alist (for \"association list\") should be a list of pairs. Proc should accept one argument and return a single value. Proc should not mutate alist. The procedure finds the first pair in alist whose car field satisfies a given condition, and returns that pair without traversing alist further. If no pair in alist satisfies the condition, then #f is returned. The assp procedure successively applies proc to the car fields of alist and looks for a pair for which it returns a true value. Proc is always called in the same dynamic environment as assp itself."))
 ((name . "assoc")
  (signature lambda (obj (list? alist)) (or pair? #f))
  (subsigs (alist (alist key value)))
  (tags pure)
  (desc . " Alist (for \"association list\") should be a list of pairs. The procedure finds the first pair in alist whose car field satisfies a given condition, and returns that pair without traversing alist further. If no pair in alist satisfies the condition, then #f is returned. The assoc procedure looks for a pair that has obj as its car. The assoc procedure uses equal? to compare obj with the car fields of the pairs in alist."))
 ((name . "assq")
  (signature lambda (obj (list? alist)) (or pair? #f))
  (subsigs (alist (alist key value)))
  (tags pure)
  (desc . " Alist (for \"association list\") should be a list of pairs. The procedure finds the first pair in alist whose car field satisfies a given condition, and returns that pair without traversing alist further. If no pair in alist satisfies the condition, then #f is returned. The assoc procedure looks for a pair that has obj as its car. The assq procedure uses eq? to compare obj with the car fields of the pairs in alist."))
 ((name . "assv")
  (signature lambda (obj (list? alist)) (or pair? #f))
  (subsigs (alist (alist key value)))
  (tags pure)
  (desc . " Alist (for \"association list\") should be a list of pairs. The procedure finds the first pair in alist whose car field satisfies a given condition, and returns that pair without traversing alist further. If no pair in alist satisfies the condition, then #f is returned. The assoc procedure looks for a pair that has obj as its car. The assv procedure uses eqv? to compare obj with the car fields of the pairs in alist."))
 ((name . "cons*") 
  (signature lambda (elt1 elt2 ...) *)
  (tags pure)
  (desc . "If called with at least two arguments, cons* returns a freshly allocated chain of pairs whose cars are obj1, ..., objn, and whose last cdr is obj. If called with only one argument, cons* returns that argument.")))
