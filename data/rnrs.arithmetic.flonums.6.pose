(((name . "flonum?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "Returns #t if obj is a flonum, #f otherwise."))
 ((name . "real->flonum") 
  (signature lambda ((real? x)) flonum?)
  (tags pure)
  (desc . " Returns the best flonum representation of x. The value returned is a flonum that is numerically closest to the argument.
Note: If flonums are represented in binary floating point, then implementations should break ties by preferring the floating-point representation whose least significant bit is zero."))
 ((name . "fl=?")
  (signature lambda ((flonum? x) (flonum? y) (flonum? z) ...) boolean?)
  (tags pure)
  (desc . "The procedure returns #t if its arguments are equal, #f otherwise. The predicate must be transitive."))
 ((name . "fl<?")
  (signature lambda ((flonum? x) (flonum? y) (flonum? z) ...) boolean?)
  (tags pure)
  (desc . "The procedure returns #t if its arguments are monotonically increasing, #f otherwise. The predicate must be transitive."))
 ((name . "fl>?")
  (signature lambda ((flonum? x) (flonum? y) (flonum? z) ...) boolean?)
  (tags pure)
  (desc . "The procedure returns #t if its arguments are monotonically decreasing, #f otherwise. The predicate must be transitive."))
 ((name . "fl<=?")
  (signature lambda ((flonum? x) (flonum? y) (flonum? z) ...) boolean?)
  (tags pure)
  (desc . "The procedure returns #t if its arguments are monotonically nondecreasing, #f otherwise. The predicate must be transitive."))
 ((name . "fl>=?")
  (signature lambda ((flonum? x) (flonum? y) (flonum? z) ...) boolean?)
  (tags pure)
  (desc . "The procedure returns #t if its arguments are monotonically nonincreasing, #f otherwise. The predicate must be transitive."))
 ((name . "flinteger?") 
  (signature lambda ((flonum? x)) boolean?)
  (tags pure)
  (desc . "Test the number is an integer"))
 ((name . "flzero?") 
  (signature lambda ((flonum? x)) boolean?)
  (tags pure)
  (desc . "Test the number is a zero"))
 ((name . "flpositive?")
  (signature lambda ((flonum? x)) boolean?)
  (tags pure)
  (desc . "Test the number is greater than zero"))
 ((name . "flnegative?")
  (signature lambda ((flonum? x)) boolean?)
  (tags pure)
  (desc . "Test the number is less than zero"))
 ((name . "flodd?")
  (signature lambda ((flonum? x)) boolean?)
  (tags pure)
  (desc . "Test the number is odd"))
 ((name . "fleven?")
  (signature lambda ((flonum? x)) boolean?)
  (tags pure)
  (desc . "Test the number is even"))
 ((name . "flfinite?")
  (signature lambda ((flonum? x)) boolean?)
  (tags pure)
  (desc . "Test the number is not infinite"))
 ((name . "flinfinite?")
  (signature lambda ((flonum? x)) boolean?)
  (tags pure)
  (desc . "Test the number is an infinity"))
 ((name . "flnan?")
  (signature lambda ((flonum? x)) boolean?)
  (tags pure)
  (desc . "Test the number is Not A Number"))
 ((name . "flmax") 
  (signature lambda ((flonum? x) ...) flonum?)
  (tags pure)
  (desc . "The procedure returns the maximum of its arguments. It always returns a NaN when one or more of the arguments is a NaN."))
 ((name . "flmin")
  (signature lambda ((flonum? x) ...) flonum?)
  (tags pure)
  (desc . "The procedure returns the minimum of its arguments. It always returns a NaN when one or more of the arguments is a NaN."))
 ((name . "fl+")
  (signature lambda ((flonum? x) ...) flonum?)
  (tags pure)
  (desc . "The procedure returns the flonum sum of its flonum arguments. In general, it should return the flonum that best approximates the mathematical sum. (For implementations that represent flonums using IEEE binary floating point, the meaning of \"best\" is defined by the IEEE standards.)"))
 ((name . "fl*")
  (signature lambda ((flonum? x) ...) flonum?)
  (tags pure)
  (desc . "The procedure returns the flonum product of its flonum arguments. In general, it should return the flonum that best approximates the mathematical product. (For implementations that represent flonums using IEEE binary floating point, the meaning of \"best\" is defined by the IEEE standards.)"))
 ((name . "fl-")
  (signature
   case-lambda
   (((flonum? x)) flonum?)
   (((flonum? x) (flonum? y) ...) flonum?))
  (tags pure)
  (desc . "With two or more arguments, the procedure returns the flonum difference of its flonum arguments, associating to the left. With one argument, however, it returns the additive flonum inverse of its argument. In general, it should return the flonum that best approximates the mathematical difference. (For implementations that represent flonums using IEEE binary floating point, the meaning of \"best\" is reasonably well-defined by the IEEE standards.)"))
 ((name . "fl/")
  (signature
   case-lambda
   (((flonum? x)) flonum?)
   (((flonum? x) (flonum? y) ...) flonum?))
  (tags pure)
  (desc . "With two or more arguments, the procedure returns the flonum quotient of its flonum arguments, associating to the left. With one argument, however, it returns the multiplicative flonum inverse of its argument. In general, it should return the flonum that best approximates the mathematical quotient. (For implementations that represent flonums using IEEE binary floating point, the meaning of \"best\" is reasonably well-defined by the IEEE standards.)"))
 ((name . "flabs")
  (signature lambda ((flonum? fl)) flonum?)
  (tags pure)
  (desc . "Returns the absolute value of fl."))
 ((name . "fldiv")
  (signature lambda ((flonum? x1) (flonum? x2)) flonum?)
  (tags pure)
  (desc . "Implements number-theoretic integer division and returns the results of the corresponding mathematical operations specified in report section on \"Integer division\". For zero divisors, the procedure may return a NaN or some unspecified flonum."))
 ((name . "fldiv0")
  (signature lambda ((flonum? x1) (flonum? x2)) flonum?)
  (tags pure)
  (desc . "Implements number-theoretic integer division and returns the results of the corresponding mathematical operations specified in report section on \"Integer division\". For zero divisors, the procedure may return a NaN or some unspecified flonum."))
 ((name . "fldiv-and-mod")
  (signature lambda ((flonum? x1) (flonum? x2)) (values flonum? flonum?))
  (tags pure)
  (desc . "Implements number-theoretic integer division and returns the results of the corresponding mathematical operations specified in report section on \"Integer division\". For zero divisors, the procedure may return a NaN or some unspecified flonum."))
 ((name . "fldiv0-and-mod0")
  (signature lambda ((flonum? x1) (flonum? x2)) (values flonum? flonum?))
  (tags pure)
  (desc . "Implements number-theoretic integer division and returns the results of the corresponding mathematical operations specified in report section on \"Integer division\". For zero divisors, the procedure may return a NaN or some unspecified flonum."))
 ((name . "flmod")
  (signature lambda ((flonum? x1) (flonum? x2)) flonum?)
  (tags pure)
  (desc . "Implements number-theoretic integer division and returns the results of the corresponding mathematical operations specified in report section on \"Integer division\". For zero divisors, the procedure may return a NaN or some unspecified flonum."))
 ((name . "flmod0")
  (signature lambda ((flonum? x1) (flonum? x2)) flonum?)
  (tags pure)
  (desc . "Implements number-theoretic integer division and returns the results of the corresponding mathematical operations specified in report section on \"Integer division\". For zero divisors, the procedure may return a NaN or some unspecified flonum."))
 ((name . "flnumerator") 
  (signature lambda ((flonum? fl)) flonum?)
  (tags pure)
  (desc . "The procedure returns the numerator of fl as a flonum; the result is computed as if fl was represented as a fraction in lowest terms."))
 ((name . "fldenominator")
  (signature lambda ((flonum? fl)) flonum?)
  (tags pure)
  (desc . "The procedure returns the denominator of fl as a flonum; the result is computed as if fl was represented as a fraction in lowest terms. The denominator is always positive. The denominator of 0.0 is defined to be 1.0."))
 ((name . "flfloor") 
  (signature lambda ((flonum? fl)) flonum?)
  (tags pure)
  (desc . "Returns the largest integral flonum not larger than fl. Returns an infinity when given an infinity as an argument, and a NaN when given a NaN."))
 ((name . "flceiling")
  (signature lambda ((flonum? fl)) flonum?)
  (tags pure)
  (desc . "Returns the smallest integral flonum not smaller than fl. Returns an infinity when given an infinity as an argument, and a NaN when given a NaN."))
 ((name . "flround") 
  (signature lambda ((flonum? fl)) flonum?)
  (tags pure)
  (desc . "Returns the closest integral flonum to fl, rounding to even when fl represents a number halfway between two integers. Returns an infinity when given an infinity as an argument, and a NaN when given a NaN."))
 ((name . "fltruncate")
  (signature lambda ((flonum? fl)) flonum?)
  (tags pure)
  (desc . "Returns the integral flonum closest to fl whose absolute value is not larger than the absolute value of fl. Returns an infinity when given an infinity as an argument, and a NaN when given a NaN."))
 ((group
    ((name . "flexp") 
     (signature lambda ((flonum? fl)) flonum?)
     (tags pure))
    ((name . "fllog")
     (signature
       case-lambda
       (((flonum? fl)) flonum?)
       (((flonum? fl) (flonum? base)) flonum?))
     (tags pure))
    ((name . "flsin") (signature lambda ((flonum? x)) flonum?) (tags pure))
    ((name . "flcos") (signature lambda ((flonum? x)) flonum?) (tags pure))
    ((name . "fltan") (signature lambda ((flonum? x)) flonum?) (tags pure))
    ((name . "flasin") (signature lambda ((flonum? x)) flonum?) (tags pure))
    ((name . "flacos") (signature lambda ((flonum? x)) flonum?) (tags pure))
    ((name . "flatan")
     (signature
       case-lambda
       (((flonum? x)) flonum?)
       (((flonum? y) (flonum? x)) flonum?))
     (tags pure)))
  (desc . "These procedures compute the usual transcendental functions. The flexp procedure computes the base-e exponential of fl. The fllog procedure with a single argument computes the natural logarithm of fl (not the base ten logarithm); (fllog fl1 fl2) computes the base-fl2 logarithm of fl1. The flasin, flacos, and flatan procedures compute arcsine, arccosine, and arctangent, respectively. (flatan fl1 fl2) computes the arc tangent of fl1/fl2.
See report section on \"Transcendental functions\" for the underlying mathematical operations. In the event that these operations do not yield a real result for the given arguments, the result may be a NaN, or may be some unspecified flonum.
Implementations that use IEEE binary floating-point arithmetic should follow the relevant standards for these procedures."))
 ((name . "flsqrt")
  (signature lambda ((flonum? fl)) flonum?)
  (tags pure)
  (desc . "Returns the principal square root of fl. For −0.0, flsqrt should return −0.0; for other negative arguments, the result may be a NaN or some unspecified flonum."))
 ((name . "flexpt")
  (signature lambda ((flonum? base) (flonum? power)) flonum?)
  (tags pure)
  (desc . "Either base should be non-negative, or, if base is negative, power should be an integer object. The flexpt procedure returns base raised to the power power. If base is negative and power is not an integer object, the result may be a NaN, or may be some unspecified flonum. If base is zero, then the result is zero."))
 ((group
    ((name . "&no-infinities") (signature value record-type-descriptor?))
    ((name . "make-no-infinities-violation")
     (signature lambda (obj) no-infinities-violation?)
     (tags pure))
    ((name . "no-infinities-violation?")
     (signature lambda (obj) boolean?)
     (tags pure predicate))
    ((name . "&no-nans") (signature value record-type-descriptor?))
    ((name . "make-no-nans-violation")
     (signature lambda (obj) no-nans-violation?)
     (tags pure))
    ((name . "no-nans-violation?")
     (signature lambda (obj) boolean?)
     (tags pure predicate)))
  (desc . "These condition types could be defined by the following code:
(define-condition-type &no-infinities
                       &implementation-restriction
                       make-no-infinities-violation
                       no-infinities-violation?)

(define-condition-type &no-nans
                       &implementation-restriction
                       make-no-nans-violation
                       no-nans-violation?)

These types describe that a program has executed an arithmetic operations that is specified to return an infinity or a NaN, respectively, on a Scheme implementation that is not able to represent the infinity or NaN. (See report section on \"Representability of infinities and NaNs\".)"))
 ((name . "fixnum->flonum")
  (signature lambda ((fixnum? fx)) flonum?)
  (tags pure)
  (desc . "Returns a flonum that is numerically closest to fx.")))
