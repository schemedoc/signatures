(((name . "array?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "Returns #t if the obj is an array, and #f if not.
Note: Arrays are not disjoint from other Scheme types. Vectors and possibly strings also satisfy array?."))
 ((name . "equal?") 
  (signature lambda (obj1 obj2) boolean?)
  (tags pure)
  (desc . "Returns #t if obj1 and obj2 have the same rank and dimensions and the corresponding elements of obj1 and obj2 are equal?.
equal? recursively compares the contents of pairs, vectors, strings, and arrays, applying eqv? on other objects such as numbers and symbols. A rule of thumb is that objects are generally equal? if they print the same. equal? may fail to terminate if its arguments are circular data structures."))
 ((name . "array-rank") 
  (signature lambda (obj) integer?)
  (tags pure)
  (desc . "Returns the number of dimensions of obj. If obj is not an array, 0 is returned."))
 ((name . "array-dimnesions")
  (signature lambda ((array? array)) list?)
  (tags pure)
  (subsigs
    (return (list integer?)))
  (desc . "Returns a list of dimensions."))
 ((name . "make-array")
  (signature lambda ((array? prototype) (integer? k1) ...) array?)
  (tags pure)
  (desc . "Creates and returns an array of type prototype with dimensions k1, ... and filled with elements from prototype. prototype must be an array, vector, or string. The implementation-dependent type of the returned array will be the same as the type of prototype; except if that would be a vector or string with rank not equal to one, in which case some variety of array will be returned.
If the prototype has no elements, then the initial contents of the returned array are unspecified. Otherwise, the returned array will be filled with the element at the origin of prototype."))
 ((name . "make-shared-array")
  (signature
   lambda
   ((array? array) (procedure? mapper) (integer? k1) ...)
   array?)
  (subsigs (mapper (lambda ((integer? i1) ...) list?)))
  (tags pure)
  (desc . "make-shared-array can be used to create shared subarrays of other arrays. The mapper is a function that translates coordinates in the new array into coordinates in the old array. A mapper must be linear, and its range must stay within the bounds of the old array, but it can be otherwise arbitrary."))
 ((name . "list->array")
  (signature lambda ((integer? rank) (array? proto) (list? list)) array?)
  (tags pure)
  (desc . "list must be a rank-nested list consisting of all the elements, in row-major order, of the array to be created."))
 ((name . "array->list") 
  (signature lambda ((array? array)) *)
  (tags pure)
  (desc . "Returns a rank-nested list consisting of all the elements, in row-major order, of array. In the case of a rank-0 array, array->list returns the single element."))
 ((name . "vector->array")
  (signature lambda ((vector? vect) (array? proto) (integer? dim1) ...) array?)
  (tags pure)
  (desc . "vect must be a vector of length equal to the product of exact nonnegative integers dim1, ....
vector->array returns an array of type proto consisting of all the elements, in row-major order, of vect. In the case of a rank-0 array, vect has a single element."))
 ((name . "array->vector")
  (signature lambda ((array? array)) vector?)
  (tags pure)
  (desc . "Returns a new vector consisting of all the elements of array in row-major order."))
 ((name . "array-in-bounds?")
  (signature lambda ((array? array) (integer? index1) ...) boolean?)
  (tags pure)
  (desc . "Returns #t if its arguments would be acceptable to array-ref."))
 ((name . "array-ref")
  (signature lambda ((array? array) (integer? index1) ...) *)
  (tags pure)
  (desc . "Returns the (k1, ...) element of array."))
 ((name . "array-set!")
  (signature lambda ((array? array) obj (integer? index1) ...) undefined)
  (desc . "Stores obj in the (k1, ...) element of array. The value returned by array-set! is unspecified.
These functions return a prototypical uniform-array enclosing the optional argument (which must be of the correct type). If the uniform-array type is supported by the implementation, then it is returned; defaulting to the next larger precision type; resorting finally to vector."))
 ((name . "A:floC128b")
  (signature case-lambda (() array?) (((complex? z)) array?))
  (tags pure)
  (desc . "Returns an inexact 128.bit flonum complex uniform-array prototype."))
 ((name . "A:floC64b")
  (signature case-lambda (() array?) (((complex? z)) array?))
  (tags pure)
  (desc . "Returns an inexact 64.bit flonum complex uniform-array prototype."))
 ((name . "A:floC32b")
  (signature case-lambda (() array?) (((complex? z)) array?))
  (tags pure)
  (desc . "Returns an inexact 32.bit flonum complex uniform-array prototype."))
 ((name . "A:floC16b")
  (signature case-lambda (() array?) (((complex? z)) array?))
  (tags pure)
  (desc . "Returns an inexact 16.bit flonum complex uniform-array prototype."))
 ((name . "A:floR128b")
  (signature case-lambda (() array?) (((real? z)) array?))
  (tags pure)
  (desc . "Returns an inexact 128.bit flonum real uniform-array prototype."))
 ((name . "A:floR64b")
  (signature case-lambda (() array?) (((real? z)) array?))
  (tags pure)
  (desc . "Returns an inexact 64.bit flonum real uniform-array prototype."))
 ((name . "A:floR32b")
  (signature case-lambda (() array?) (((real? z)) array?))
  (tags pure)
  (desc . "Returns an inexact 32.bit flonum real uniform-array prototype."))
 ((name . "A:floR16b")
  (signature case-lambda (() array?) (((real? z)) array?))
  (tags pure)
  (desc . "Returns an inexact 16.bit flonum real uniform-array prototype."))
 ((name . "A:floQ128d")
  (signature case-lambda (() array?) (((real? z)) array?))
  (tags pure)
  (desc . "Returns an exact 128.bit decimal flonum rational uniform-array prototype."))
 ((name . "A:floQ64d")
  (signature case-lambda (() array?) (((real? z)) array?))
  (tags pure)
  (desc . "Returns an exact 64.bit decimal flonum rational uniform-array prototype."))
 ((name . "A:floQ32d")
  (signature case-lambda (() array?) (((real? z)) array?))
  (tags pure)
  (desc . "Returns an exact 32.bit decimal flonum rational uniform-array prototype."))
 ((name . "A:fixZ64b")
  (signature case-lambda (() array?) (((integer? z)) array?))
  (tags pure)
  (desc . "Returns an exact binary fixnum uniform-array prototype with at least 64 bits of precision."))
 ((name . "A:fixZ32b")
  (signature case-lambda (() array?) (((integer? z)) array?))
  (tags pure)
  (desc . "Returns an exact binary fixnum uniform-array prototype with at least 32 bits of precision."))
 ((name . "A:fixZ16b")
  (signature case-lambda (() array?) (((integer? z)) array?))
  (tags pure)
  (desc . "Returns an exact binary fixnum uniform-array prototype with at least 16 bits of precision."))
 ((name . "A:fixZ8b")
  (signature case-lambda (() array?) (((integer? z)) array?))
  (tags pure)
  (desc . "Returns an exact binary fixnum uniform-array prototype with at least 8 bits of precision."))
 ((name . "A:fixN64b")
  (signature case-lambda (() array?) (((integer? z)) array?))
  (tags pure)
  (desc . "Returns an exact non-negative binary fixnum uniform-array prototype with at least 64 bits of precision."))
 ((name . "A:fixN32b")
  (signature case-lambda (() array?) (((integer? z)) array?))
  (tags pure)
  (desc . "Returns an exact non-negative binary fixnum uniform-array prototype with at least 32 bits of precision."))
 ((name . "A:fixN16b")
  (signature case-lambda (() array?) (((integer? z)) array?))
  (tags pure)
  (desc . "Returns an exact non-negative binary fixnum uniform-array prototype with at least 16 bits of precision."))
 ((name . "A:fixN8b")
  (signature case-lambda (() array?) (((integer? z)) array?))
  (tags pure)
  (desc . "Returns an exact non-negative binary fixnum uniform-array prototype with at least 8 bits of precision."))
 ((name . "A:bool")
  (signature case-lambda (() array?) (((boolean? b)) array?))
  (tags pure)
  (desc . "Returns a boolean uniform-array prototype.")))
