(((name . "and-let*")
  (signature syntax-rules () ((_ (claw ...) body)))
  (subsigs
   (claw (pattern (variable expression) (expression) bound-variable)))
  (desc . "In case of an ordinary AND formed of proper boolean expressions: (AND E1 E2 ...) expression E2, if it gets to be evaluated, knows that E1 has returned non-#f. Moreover, E2 knows exactly what the result of E1 was -- #t -- which E2 can use to its advantage. If E1 however is an extended boolean expression, E2 can no longer tell which particular non-#f value E1 has returned. Chances are it took a lot of work to evaluate E1, and the produced result (a number, a vector, a string, etc) may be of value to E2. Alas, the AND form merely checks that the result is not an #f, and throws it away. If E2 needs it, it has to compute that value anew. This proposed AND-LET* special form lets constituent expressions get hold of the results of already evaluated expressions, without re-doing their work.
AND-LET* can be thought of as a combination of LET* and AND, or a generalization of COND's send operator =>. An AND-LET* form can also be considered a sequence of guarded expressions. In a regular program, forms may produce results, bind them to variables and let other forms use these results. AND-LET* differs in that it checks to make sure that every produced result \"makes sense\" (that is, not an #f). The first \"failure\" triggers the guard and aborts the rest of the sequence (which presumably would not make any sense to execute anyway).")))
