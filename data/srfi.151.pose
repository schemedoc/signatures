(((name . "bitwise-not")
  (signature lambda ((integer? i)) integer?)
  (tags pure)
  (desc . "Returns the bitwise complement of i; that is, all 1 bits are changed to 0 bits and all 0 bits to 1 bits."))
 ((group
    ((name . "bitwise-and")
     (signature lambda ((integer? i) ...) integer?)
     (tags pure))
    ((name . "bitwise-ior")
     (signature lambda ((integer? i) ...) integer?)
     (tags pure))
    ((name . "bitwise-xor")
     (signature lambda ((integer? i) ...) integer?)
     (tags pure))
    ((name . "bitwise-eqv")
     (signature lambda ((integer? i) ...) integer?)
     (tags pure)))
  (desc . "For each function, the corresponding bitwise operator maps that function across a pair of bitstrings in a bit-wise fashion. These operations are associative. When passed no arguments, the procedures return the identity values -1, 0, 0, and -1 respectively."))
 ((group
    ((name . "bitwise-nand")
     (signature lambda ((integer? i) (integer? j)) integer?)
     (tags pure))
    ((name . "bitwise-nor")
     (signature lambda ((integer? i) (integer? j)) integer?)
     (tags pure))
    ((name . "bitwise-andc1")
     (signature lambda ((integer? i) (integer? j)) integer?)
     (tags pure))
    ((name . "bitwise-andc2")
     (signature lambda ((integer? i) (integer? j)) integer?)
     (tags pure))
    ((name . "bitwise-orc1")
     (signature lambda ((integer? i) (integer? j)) integer?)
     (tags pure))
    ((name . "bitwise-orc2")
     (signature lambda ((integer? i) (integer? j)) integer?)
     (tags pure)))
  (desc . "For each function, the corresponding bitwise operator maps that function across a pair of bitstrings in a bit-wise fashion. These operations are not associative."))
 ((name . "arithmetic-shift")
  (signature lambda ((integer? i) (integer? count)) integer?)
  (tags pure)
  (desc . "Returns the arithmetic left shift when count>0; right shift when count<0."))
 ((name . "bit-count")
  (signature lambda ((integer? i)) integer?)
  (tags pure)
  (desc . "Returns the population count of 1's (i >= 0) or 0's (i < 0). The result is always non-negative."))
 ((name . "integer-length")
  (signature lambda ((integer? i)) integer?)
  (tags pure)
  (desc . "The number of bits needed to represent i"))
 ((name . "bitwise-if")
  (signature lambda ((integer? mask) (integer? i) (integer? j)) integer?)
  (tags pure)
  (desc . "Merge the bitstrings i and j, with bitstring mask determining from which string to take each bit. That is, if the kth bit of mask is 1, then the kth bit of the result is the kth bit of i, otherwise the kth bit of j. "))
 ((name . "bit-set?")
  (signature lambda ((integer? index) (integer? i)) boolean?)
  (tags pure)
  (desc . "Is bit index set in bitstring i (where index is a non-negative exact integer)? "))
 ((name . "copy-bit")
  (signature
   lambda
   ((integer? index) (integer? i) (boolean? boolean))
   integer?)
  (tags pure)
  (desc . "Returns an integer the same as i except in the indexth bit, which is 1 if boolean is #t and 0 if boolean is #f."))
 ((name . "bit-swap")
  (signature
   lambda
   ((integer? index1) (integer? index2) (integer? i))
   integer?)
  (tags pure)
  (desc . "Returns an integer the same as i except that the index1th bit and the index2th bit have been exchanged."))
 ((group
    ((name . "any-bit-set?")
     (signature lambda ((integer? test-bits) (integer? i)) boolean?)
     (tags pure))
    ((name . "every-bit-set?")
     (signature lambda ((integer? test-bits) (integer? i)) boolean?)
     (tags pure)))
  (desc . "Determines if any/all of the bits set in bitstring test-bits are set in bitstring i. I.e., returns (not (zero? (bitwise-and test-bits i))) and (= test-bits (bitwise-and test-bits i))) respectively."))
 ((name . "first-set-bit")
  (signature lambda ((integer? i)) integer?)
  (tags pure)
  (desc . "Return the index of the first (smallest index) 1 bit in bitstring i. Return -1 if i contains no 1 bits (i.e., if i is zero)."))
 ((name . "bit-field")
  (signature lambda ((integer? i) (integer? start) (integer? end)) integer?)
  (tags pure)
  (desc . "Returns the field from i, shifted down to the least-significant position in the result."))
 ((name . "bit-field-any?")
  (signature lambda ((integer? i) (integer? start) (integer? end)) boolean?)
  (tags pure)
  (desc . "Returns true if any of the field's bits are set in bitstring i, and false otherwise."))
 ((name . "bit-field-every?")
  (signature lambda ((integer? i) (integer? start) (integer? end)) boolean?)
  (tags pure)
  (desc . "Returns false if any of the field's bits are not set in bitstring i, and true otherwise."))
 ((group
    ((name . "bit-field-clear")
     (signature lambda ((integer? i) (integer? start) (integer? end)) integer?)
     (tags pure))
    ((name . "bit-field-set")
     (signature lambda ((integer? i) (integer? start) (integer? end)) integer?)
     (tags pure)))
  (desc . "Returns i with the field's bits set to all 0s/1s."))
 ((name . "bit-field-replace")
  (signature
   lambda
   ((integer? dest) (integer? source) (integer? start) (integer? end))
   integer?)
  (tags pure)
  (desc . "Returns dest with the field replaced by the least-significant end-start bits in source."))
 ((name . "bit-field-replace-same")
  (signature
   lambda
   ((integer? dest) (integer? source) (integer? start) (integer? end))
   integer?)
  (tags pure)
  (desc . "Returns dest with its field replaced by the corresponding field in source."))
 ((name . "bit-field-rotate")
  (signature
   lambda
   ((integer? i) (integer? count) (integer? start) (integer? end))
   integer?)
  (tags pure)
  (desc . "Returns i with the field cyclically permuted by count bits towards high-order."))
 ((name . "bit-field-reverse")
  (signature lambda ((integer? i) (integer? start) (integer? end)) integer?)
  (tags pure)
  (desc . "Returns i with the order of the bits in the field reversed."))
 ((group
    ((name . "bits->list")
     (signature
       case-lambda
       (((integer? i)) list?)
       (((integer? i) (integer? len)) list?))
     (subsigs
       (return (list (boolean? b))))
     (tags pure))
    ((name . "bits->vector")
     (signature
       case-lambda
       (((integer? i)) vector?)
       (((integer? i) (integer? len)) vector?))
     (subsigs
       (return (vector (boolean? b))))
     (tags pure)))
  (desc . "Returns a list/vector of len booleans corresponding to each bit of the non-negative integer i, returning bit #0 as the first element, bit #1 as the second, and so on. #t is returned for each 1; #f for 0."))
 ((group
    ((name . "list->bits") 
     (signature lambda ((list? list)) integer?)
     (subsigs
       (list (list (boolean? b))))
     (tags pure))
    ((name . "vector->bits")
     (signature lambda ((vector? vector)) integer?)
     (subsigs
       (vector (vector (boolean? b))))
     (tags pure)))
  (desc . "Returns an integer formed from the booleans in list/vector, using the first element as bit #0, the second element as bit #1, and so on. It is an error if list/vector contains non-booleans. A 1 bit is coded for each #t; a 0 bit for #f. Note that the result is never a negative integer."))
 ((name . "bits")
  (signature lambda ((boolean? bool) ...) integer?)
  (tags pure)
  (desc . "Returns the integer coded by the bool arguments. The first argument is bit #0, the second argument is bit #1, and so on. Note that the result is never a negative integer."))
 ((name . "bitwise-fold")
  (signature lambda ((procedure? proc) seed (integer? i)) *)
  (subsigs (proc (lambda ((boolean? bit) state) *)))
  (tags pure)
  (desc . "For each bit b of i from bit #0 (inclusive) to bit (integer-length i) (exclusive), proc is called as (proc b r), where r is the current accumulated result. The initial value of r is seed, and the value returned by proc becomes the next accumulated result. When the last bit has been processed, the final accumulated result becomes the result of bitwise-fold."))
 ((name . "bitwise-for-each")
  (signature lambda ((procedure? proc) (integer? i)) undefined)
  (subsigs (proc (lambda ((boolean? bit)) undefined)))
  (desc . "Repeatedly applies proc to the bits of i starting with bit #0 (inclusive) and ending with bit (integer-length i) (exclusive). The values returned by proc are discarded. Returns an unspecified value."))
 ((name . "bitwise-unfold")
  (signature
   lambda
   ((procedure? stop?) (procedure? mapper) (procedure? successor) seed)
   integer?)
  (subsigs
   (stop? (lambda (seed) boolean?))
   (mapper (lambda (seed) boolean?))
   (successor (lambda (seed) *)))
  (tags pure)
  (desc . "Generates a non-negative integer bit by bit, starting with bit 0. If the result of applying stop? to the current state (whose initial value is seed) is true, return the currently accumulated bits as an integer. Otherwise, apply mapper to the current state to obtain the next bit of the result by interpreting a true value as a 1 bit and a false value as a 0 bit. Then get a new state by applying successor to the current state, and repeat this algorithm."))
 ((name . "make-bitwise-generator")
  (signature lambda ((integer? i)) procedure?)
  (subsigs (return (lambda () boolean?)))
  (desc . "Returns a SRFI 121 generator that generates all the bits of i starting with bit #0. Note that the generator is infinite.")))
