(((name . "current-thread")
  (signature lambda () thread?)
  (desc . "Returns the current thread."))
 ((name . "thread?")
  (signature lambda (object) boolean?)
  (tags pure predicate)
  (desc . "Returns #t if obj is a thread, otherwise returns #f."))
 ((name . "make-thread")
  (signature
   case-lambda
   (((procedure? thunk)) thread?)
   (((procedure? thunk) name) thread?))
  (subsigs (thunk (lambda () *)))
  (desc . "Returns a new thread. This thread is not automatically made runnable (the procedure thread-start! must be used for this). A thread has the following fields: name, specific, end-result, end-exception, and a list of locked/owned mutexes it owns. The thread's execution consists of a call to thunk with the \"initial continuation\". This continuation causes the (then) current thread to store the result in its end-result field, abandon all mutexes it owns, and finally terminate. The dynamic-wind stack of the initial continuation is empty. The optional name is an arbitrary Scheme object which identifies the thread (useful for debugging); it defaults to an unspecified value. The specific field is set to an unspecified value. The thread inherits the dynamic environment from the current thread. Moreover, in this dynamic environment the exception handler is bound to the \"initial exception handler\" which is a unary procedure which causes the (then) current thread to store in its end-exception field an \"uncaught exception\" object whose \"reason\" is the argument of the handler, abandon all mutexes it owns, and finally terminate."))
 ((name . "thread-name") 
  (signature lambda ((thread? thread)) *)
  (tags pure)
  (desc . "Returns the name of the thread."))
 ((name . "thread-specific")
  (signature lambda ((thread? thread)) *)
  (tags pure)
  (desc . "Returns the content of the thread's specific field."))
 ((name . "thread-specific-set!")
  (signature lambda ((thread? thread) obj) undefined)
  (desc . "Stores obj into the thread's specific field. thread-specific-set! returns an unspecified value."))
 ((name . "thread-start!") 
  (signature lambda ((thread? thread)) undefined)
  (desc . "Makes thread runnable. The thread must be a new thread. thread-start! returns the thread."))
 ((name . "thread-yield!") 
  (signature lambda ((thread? thread)) undefined)
  (desc . "The current thread exits the running state as if its quantum had expired. thread-yield! returns an unspecified value."))
 ((name . "thread-sleep!") 
  (signature lambda ((integer? timeout)) undefined)
  (desc . "The current thread waits until the timeout is reached. This blocks the thread only if timeout represents a point in the future. It is an error for timeout to be #f. thread-sleep! returns an unspecified value."))
 ((name . "thread-terminate!") 
  (signature lambda ((thread? thread)) undefined)
  (desc . "Causes an abnormal termination of the thread. If the thread is not already terminated, all mutexes owned by the thread become unlocked/abandoned and a \"terminated thread exception\" object is stored in the thread's end-exception field. If thread is the current thread, thread-terminate! does not return. Otherwise thread-terminate! returns an unspecified value; the termination of the thread will occur before thread-terminate! returns."))
 ((name . "thread-join!")
  (signature
   case-lambda
   (((thread? thread)) *)
   (((thread? thread) (integer? timeout)) *)
   (((thread? thread) (integer? timeout) timeout-val) *))
  (desc . "The current thread waits until the thread terminates (normally or not) or until the timeout is reached if timeout is supplied. If the timeout is reached, thread-join! returns timeout-val if it is supplied, otherwise a \"join timeout exception\" is raised. If the thread terminated normally, the content of the end-result field is returned, otherwise the content of the end-exception field is raised."))
 ((name . "mutex?") 
  (signature lambda (object) boolean?)
  (tags pure predicate)
  (desc . "Returns #t if obj is a mutex, otherwise returns #f."))
 ((name . "make-mutex") 
  (signature case-lambda (() mutex?) ((name) mutex?))
  (desc . "Returns a new mutex in the unlocked/not-abandoned state. The optional name is an arbitrary Scheme object which identifies the mutex (useful for debugging); it defaults to an unspecified value. The mutex's specific field is set to an unspecified value."))
 ((name . "mutex-name") 
  (signature lambda ((mutex? mutex)) *)
  (tags pure)
  (desc . "Returns the name of the mutex."))
 ((name . "mutex-specific") 
  (signature lambda ((mutex? mutex)) *)
  (tags pure)
  (desc . "Returns the content of the mutex's specific field."))
 ((name . "mutex-specific-set!")
  (signature lambda ((mutex? mutex) obj) undefined)
  (desc . "Stores obj into the mutex's specific field. mutex-specific-set! returns an unspecified value."))
 ((name . "mutex-state")
  (signature lambda ((mutex? mutex)) (or thread? symbol?))
  (desc . " Returns information about the state of the mutex. The possible results are:
* thread T: the mutex is in the locked/owned state and thread T is the owner of the mutex
* symbol not-owned: the mutex is in the locked/not-owned state
* symbol abandoned: the mutex is in the unlocked/abandoned state
* symbol not-abandoned: the mutex is in the unlocked/not-abandoned state "))
 ((name . "mutex-lock!")
  (signature
   case-lambda
   (((mutex? mutex)) boolean?)
   (((mutex? mutex) (integer? timeout)) boolean?)
   (((mutex? mutex) (integer? timeout) ((or #f thread?) thread)) boolean?))
  (desc . "If the mutex is currently locked, the current thread waits until the mutex is unlocked, or until the timeout is reached if timeout is supplied. If the timeout is reached, mutex-lock! returns #f. Otherwise, the state of the mutex is changed as follows:
* if thread is #f the mutex becomes locked/not-owned,
* otherwise, let T be thread (or the current thread if thread is not supplied),
  if T is terminated the mutex becomes unlocked/abandoned,
  otherwise mutex becomes locked/owned with T as the owner. 

After changing the state of the mutex, an \"abandoned mutex exception\" is raised if the mutex was unlocked/abandoned before the state change, otherwise mutex-lock! returns #t. It is not an error if the mutex is owned by the current thread (but the current thread will have to wait)."))
 ((name . "mutex-unlock!")
  (signature
   case-lambda
   (((mutex? mutex)) boolean?)
   (((mutex? mutex) (condition-variable? condition-variable)) boolean?)
   (((mutex? mutex)
     (condition-variable? condition-variable)
     (integer? timeout))
    boolean?))
  (desc . " Unlocks the mutex by making it unlocked/not-abandoned. It is not an error to unlock an unlocked mutex and a mutex that is owned by any thread. If condition-variable is supplied, the current thread is blocked and added to the condition-variable before unlocking mutex; the thread can unblock at any time but no later than when an appropriate call to condition-variable-signal! or condition-variable-broadcast! is performed (see below), and no later than the timeout (if timeout is supplied). If there are threads waiting to lock this mutex, the scheduler selects a thread, the mutex becomes locked/owned or locked/not-owned, and the thread is unblocked. mutex-unlock! returns #f when the timeout is reached, otherwise it returns #t.
NOTE: The reason the thread can unblock at any time (when condition-variable is supplied) is to allow extending this SRFI with primitives that force a specific blocked thread to become runnable. For example a primitive to interrupt a thread so that it performs a certain operation, whether the thread is blocked or not, may be useful to handle the case where the scheduler has detected a serious problem (such as a deadlock) and it must unblock one of the threads (such as the primordial thread) so that it can perform some appropriate action. After a thread blocked on a condition-variable has handled such an interrupt it would be wrong for the scheduler to return the thread to the blocked state, because any calls to condition-variable-broadcast! during the interrupt will have gone unnoticed. It is necessary for the thread to remain runnable and return from the call to mutex-unlock! with a result of #t.
NOTE: mutex-unlock! is related to the \"wait\" operation on condition variables available in other thread systems. The main difference is that \"wait\" automatically locks mutex just after the thread is unblocked. This operation is not performed by mutex-unlock! and so must be done by an explicit call to mutex-lock!. This has the advantages that a different timeout and exception handler can be specified on the mutex-lock! and mutex-unlock! and the location of all the mutex operations is clearly apparent."))
 ((name . "condition-variable?")
  (signature lambda (object) boolean?)
  (tags pure predicate)
  (desc . "Returns #t if obj is a condition variable, otherwise returns #f."))
 ((name . "make-condition-variable")
  (signature
   case-lambda
   (() condition-variable?)
   ((name) condition-variable?)
   ((name) condition-variable?))
  (desc . "Returns a new empty condition variable. The optional name is an arbitrary Scheme object which identifies the condition variable (useful for debugging); it defaults to an unspecified value. The condition variable's specific field is set to an unspecified value."))
 ((name . "condition-variable-name")
  (signature lambda ((condition-variable? condition-variable)) *)
  (tags pure)
  (desc . "Returns the name of the condition-variable."))
 ((name . "condition-variable-specific")
  (signature lambda ((condition-variable? condition-variable)) *)
  (tags pure)
  (desc . "Returns the content of the condition-variable's specific field."))
 ((name . "condition-variable-specific-set!")
  (signature lambda ((condition-variable? condition-variable) obj) undefined)
  (desc . "Stores obj into the condition-variable's specific field. condition-variable-specific-set! returns an unspecified value."))
 ((name . "condition-variable-signal!")
  (signature lambda ((condition-variable? condition-variable)) undefined)
  (desc . "If there are threads blocked on the condition-variable, the scheduler selects a thread and unblocks it. condition-variable-signal! returns an unspecified value."))
 ((name . "condition-variable-broadcast!")
  (signature lambda ((condition-variable? condition-variable)) undefined)
  (desc . "Unblocks all the threads blocked on the condition-variable. condition-variable-broadcast! returns an unspecified value."))
 ((name . "current-time") 
  (signature lambda () time?)
  (desc . "Returns the time object corresponding to the current time."))
 ((name . "time?") 
  (signature lambda (obj) boolean?) 
  (tags pure predicate)
  (desc . "Returns #t if obj is a time object, otherwise returns #f."))
 ((name . "time->seconds") 
  (signature lambda ((time? time)) real?)
  (tags pure)
  (desc . "Converts the time object time into an exact or inexact real number representing the number of seconds elapsed since some implementation dependent reference point."))
 ((name . "seconds->time")
  (signature lambda ((real? seconds)) time?)
  (tags pure)
  (desc . "Converts into a time object the exact or inexact real number x representing the number of seconds elapsed since some implementation dependent reference point."))
 ((name . "current-exception-handler")
  (signature lambda () procedure?)
  (subsigs (return (lambda (err) *)))
  (desc . "Returns the current exception handler."))
 ((name . "with-exception-handler")
  (signature lambda ((procedure? handler) (procedure? thunk)) *)
  (subsigs (handler (lambda (err) *)) (thunk (lambda () *)))
  (desc . "Returns the result(s) of calling thunk with no arguments. The handler, which must be a procedure, is installed as the current exception handler in the dynamic environment in effect during the call to thunk."))
 ((name . "raise") 
  (signature lambda (obj) undefined)
  (desc . "Calls the current exception handler with obj as the single argument. obj may be any Scheme object."))
 ((name . "join-timeout-exception?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "Returns #t if obj is a \"join timeout exception\" object, otherwise returns #f. A join timeout exception is raised when thread-join! is called, the timeout is reached and no timeout-val is supplied."))
 ((name . "abandoned-mutex-exception?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "Returns #t if obj is an \"abandoned mutex exception\" object, otherwise returns #f. An abandoned mutex exception is raised when the current thread locks a mutex that was owned by a thread which terminated (see mutex-lock!)."))
 ((name . "terminated-thread-exception?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "Returns #t if obj is a \"terminated thread exception\" object, otherwise returns #f. A terminated thread exception is raised when thread-join! is called and the target thread has terminated as a result of a call to thread-terminate!."))
 ((name . "uncaught-exception?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "Returns #t if obj is an \"uncaught exception\" object, otherwise returns #f. An uncaught exception is raised when thread-join! is called and the target thread has terminated because it raised an exception that called the initial exception handler of that thread."))
 ((name . "uncaught-exception-reason")
  (signature lambda ((uncaught-exception? exc)) *)
  (tags pure)
  (desc . "exc must be an \"uncaught exception\" object. uncaught-exception-reason returns the object which was passed to the initial exception handler of that thread.")))
