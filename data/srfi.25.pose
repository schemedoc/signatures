(((name . "array?")
  (signature lambda (obj) boolean?)
  (tags predicate pure)
  (desc . "Returns #t if obj is an array, otherwise returns #f."))
 ((name . "make-array")
  (signature
   case-lambda
   (((array? shape)) array?)
   (((array? shape) obj) array?))
  (tags pure)
  (desc . "Returns a newly allocated array whose shape is given by shape. If obj is provided, then each element is initialized to it. Otherwise the initial contents of each element is unspecified. The array does not retain a dependence to shape."))
 ((name . "shape")
  (signature lambda ((integer? lowerbound1) (integer? upperbound1) ...) array?)
  (tags pure)
  (desc . "Returns a shape. The sequence bound ... must consist of an even number of exact integers that are pairwise not decreasing. Each pair gives the lower and upper bound of a dimension. If the shape is used to specify the dimensions of an array and bound ... is the sequence b0 e0 ... bk ek ... of n pairs of bounds, then a valid index to the array is any sequence j0 ... jk ... of n exact integers where each jk satisfies (<= bk jk) and (< jk ek).
The shape of a d-dimensional array is a d Ã— 2 array where the element at k 0 contains the lower bound for an index along dimension k and the element at k 1 contains the corresponding upper bound, where k satisfies (<= 0 k) and (< k d)."))
 ((name . "array")
  (signature lambda ((array? shape) obj ...) array?)
  (tags pure)
  (desc . "Returns a new array whose shape is given by shape and the initial contents of the elements are obj ... in row major order. The array does not retain a dependence to shape."))
 ((name . "array-rank")
  (signature lambda ((array? shape)) integer?)
  (tags pure)
  (desc . "Returns the number of dimensions of array."))
 ((name . "array-start")
  (signature lambda ((array? shape) (integer? k)) integer?)
  (tags pure)
  (desc . "Returns the lower bound for the index along dimension k."))
 ((name . "array-end")
  (signature lambda ((array? shape) (integer? k)) integer?)
  (tags pure)
  (desc . "Returns the upper bound for the index along dimension k."))
 ((name . "array-ref")
  (signature
   case-lambda
   (((array? shape) (integer? k) ...) *)
   (((array? shape) ((or vector? array?) index)) *))
  (tags pure)
  (desc . "Returns the contents of the element of array at index k .... The sequence k ... must be a valid index to array. In the second form, index must be either a vector or a 0-based 1-dimensional array containing k ...."))
 ((name . "array-set!")
  (signature
   case-lambda
   (((array? shape) (integer? k) ... obj) undefined)
   (((array? shape) ((or vector? array?) index) obj) undefined))
  (desc . "Stores obj in the element of array at index k .... Returns an unspecified value. The sequence k ... must be a valid index to array. In the second form, index must be either a vector or a 0-based 1-dimensional array containing k ...."))
 ((name . "share-array")
  (signature lambda ((array? array) (array? shape) (procedure? proc)) array?)
  (subsigs (proc (lambda ((integer? index1) ...) (values integer? ...))))
  (tags pure)
  (desc . "Returns a new array of shape shape that shares elements of array through proc. The procedure proc must implement an affine function that returns indices of array when given indices of the array returned by share-array. The array does not retain a dependence to shape.")))
