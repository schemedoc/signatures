(((name . "array?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "Returns #t if the obj is an array, and #f if not. 
Note: Arrays are not disjoint from other Scheme types. Strings and vectors also satisfy array?."))
 ((name . "equal?") 
  (signature lambda (obj1 obj2) boolean?)
  (tags pure)
  (desc . "`Equal?' recursively compares the contents of pairs, vectors, strings, and arrays, applying `eqv?' on other objects such as numbers and symbols. A rule of thumb is that objects are generally `equal?' if they print the same. `Equal?' may fail to terminate if its arguments are circular data structures."))
 ((name . "make-array")
  (signature lambda ((array? prototype) (integer? k1) ...) array?)
  (tags pure)
  (desc . "Creates and returns an array of type prototype with dimensions k1, k2, ... and filled with elements from prototype. prototype must be an array, vector, or string. The implementation-dependent type of the returned array will be the same as the type of prototype. except if that would be a vector or string with more than one dimension, in which case some variety of array will be returned.
If the prototype has no elements, then the initial contents of the returned array are unspecified. Otherwise, the returned array will be filled with the element at the origin of prototype."))
 ((name . "ac64")
  (signature case-lambda (() array?) (((complex? z)) array?))
  (tags pure)
  (desc . "Returns a high-precision complex uniform-array prototype."))
 ((name . "ac32")
  (signature case-lambda (() array?) (((complex? z)) array?))
  (tags pure)
  (desc . "Returns a complex uniform-array prototype."))
 ((name . "ar64")
  (signature case-lambda (() array?) (((real? x)) array?))
  (tags pure)
  (desc . "Returns a high-precision real uniform-array prototype."))
 ((name . "ar32")
  (signature case-lambda (() array?) (((real? x)) array?))
  (tags pure)
  (desc . "Returns a real uniform-array prototype."))
 ((name . "as64")
  (signature case-lambda (() array?) (((integer? n)) array?))
  (tags pure)
  (desc . "Returns an exact signed integer uniform-array prototype with at least 64 bits of precision."))
 ((name . "as32")
  (signature case-lambda (() array?) (((integer? n)) array?))
  (tags pure)
  (desc . "Returns an exact signed integer uniform-array prototype with at least 32 bits of precision."))
 ((name . "as16")
  (signature case-lambda (() array?) (((integer? n)) array?))
  (tags pure)
  (desc . "Returns an exact signed integer uniform-array prototype with at least 16 bits of precision."))
 ((name . "as8")
  (signature case-lambda (() array?) (((integer? n)) array?))
  (tags pure)
  (desc . "Returns an exact signed integer uniform-array prototype with at least 8 bits of precision."))
 ((name . "au64")
  (signature case-lambda (() array?) (((integer? n)) array?))
  (tags pure)
  (desc . "Returns an exact non-negative integer uniform-array prototype with at least 64 bits of precision."))
 ((name . "au32")
  (signature case-lambda (() array?) (((integer? n)) array?))
  (tags pure)
  (desc . "Returns an exact non-negative integer uniform-array prototype with at least 32 bits of precision."))
 ((name . "au16")
  (signature case-lambda (() array?) (((integer? n)) array?))
  (tags pure)
  (desc . "Returns an exact non-negative integer uniform-array prototype with at least 16 bits of precision."))
 ((name . "au8")
  (signature case-lambda (() array?) (((integer? n)) array?))
  (tags pure)
  (desc . "Returns an exact non-negative integer uniform-array prototype with at least 8 bits of precision."))
 ((name . "at1")
  (signature case-lambda (() array?) (((boolean? b)) array?))
  (tags pure)
  (desc . "Returns a boolean uniform-array prototype."))
 ((name . "make-shared-array")
  (signature
   lambda
   ((array? array) (procedure? mapper) (integer? k1) ...)
   array?)
  (subsigs (mapper (lambda ((integer? i1) ...) list?)))
  (tags pure)
  (desc . "make-shared-array can be used to create shared subarrays of other arrays. The mapper is a function that translates coordinates in the new array into coordinates in the old array. A mapper must be linear, and its range must stay within the bounds of the old array, but it can be otherwise arbitrary."))
 ((name . "array-rank") 
  (signature lambda (obj) integer?)
  (tags pure)
  (desc . "Returns the number of dimensions of obj. If obj is not an array, 0 is returned."))
 ((name . "array-dimnesions")
  (signature lambda ((array? array)) list?)
  (subsigs
    (return (list integer?)))
  (tags pure)
  (desc . "Returns a list of dimensions."))
 ((name . "array-in-bounds?")
  (signature lambda ((array? array) (integer? index1) ...) boolean?)
  (tags pure)
  (desc . "Returns #t if its arguments would be acceptable to array-ref."))
 ((name . "array-ref")
  (signature lambda ((array? array) (integer? index1) ...) *)
  (tags pure)
  (desc . "Returns the (index1, index2, ...) element of array."))
 ((name . "array-set!")
  (signature lambda ((array? array) obj (integer? index1) ...) undefined)
  (desc . "Stores obj in the (index1, index2, ...) element of array. The value returned by array-set! is unspecified.")))
