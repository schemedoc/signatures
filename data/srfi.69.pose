(((name . "make-hash-table")
  (signature
   case-lambda
   (((procedure? equality-predicate) arg ...) hash-table?)
   (((procedure? equality-predicate) (procedure? hash-function) arg ...)
    hash-table?))
  (subsigs
   (equality-predicate (lambda (a b) boolean?))
   (hash-function (lambda (obj) integer?)))
  (tags pure)
  (desc . "Create a new hash table with no associations. equal? is a predicate that should accept two keys and return a boolean telling whether they denote the same key value; it defaults to equal?.
hash is a hash function, and defaults to an appropriate hash function for the given equal? predicate (see section Hashing). However, an acceptable default is not guaranteed to be given for any equivalence predicate coarser than equal?, except for string-ci=?.[1] The function hash must be acceptable for equal?, so if you use coarser equivalence than equal? other than string-ci=?, you must always provide the function hash yourself.
[1] An equivalence predicate c1 is coarser than a equivalence predicate c2 iff there exist values x and y such that (and (c1 x y) (not (c2 x y))). "))
 ((name . "hash-table?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "A predicate to test whether a given object obj is a hash table. The hash table type should be disjoint from all other types, if possible."))
 ((name . "alist->hash-table")
  (signature
   lambda
   ((list? alist) (comparator? comparator) arg ...)
   hash-table?)
  (subsigs
    (alist (alist key value)))
  (tags pure)
  (desc . "Takes an \"association list\" alist and creates a hash table hash-table which maps the car of every element in alist to the cdr of corresponding elements in alist. equal?, hash, and args are interpreted as in make-hash-table. If some key occurs multiple times in alist, the value in the first association will take precedence over later ones. (Note: the choice of using cdr (instead of cadr) for values tries to strike balance between the two approaches: using cadr would render this procedure unusable for cdr alists, but not vice versa.)"))
 ((name . "hash-table-equivalence-function")
  (signature lambda ((hash-table? hash-table)) procedure?)
  (subsigs (return (lambda (a b) boolean?)))
  (tags pure)
  (desc . "Returns the equivalence predicate used for keys of hash-table."))
 ((name . "hash-table-hash-function")
  (signature lambda ((hash-table? hash-table)) procedure?)
  (subsigs (return (lambda (obj) integer?)))
  (tags pure)
  (desc . "Returns the hash function used for keys of hash-table."))
 ((name . "hash-table-ref")
  (signature
   case-lambda
   (((hash-table? hash-table) key) *)
   (((hash-table? hash-table) key (procedure? failure)) *))
  (subsigs (failure (lambda () *)))
  (tags pure)
  (desc . "This procedure returns the value associated to key in hash-table. If no value is associated to key and thunk is given, it is called with no arguments and its value is returned; if thunk is not given, an error is signalled. Given a good hash function, this operation should have an (amortised) complexity of O(1) with respect to the number of associations in hash-table. (Note: this rules out implementation by association lists or fixed-length hash tables.)"))
 ((name . "hash-table-ref/default")
  (signature lambda ((hash-table? hash-table) key default) *)
  (tags pure)
  (desc . "Evaluates to the same value as (hash-table-ref hash-table key (lambda () default)). Given a good hash function, this operation should have an (amortised) complexity of O(1) with respect to the number of associations in hash-table. (Note: this rules out implementation by association lists or fixed-length hash tables.)"))
 ((name . "hash-table-set!")
  (signature lambda ((hash-table? hash-table) key1 value1 ...) undefined)
  (desc . "This procedure sets the value associated to key in hash-table. The previous association (if any) is removed. Given a good hash function, this operation should have an (amortised) complexity of O(1) with respect to the number of associations in hash-table. (Note: this rules out implementation by association lists or fixed-length hash tables.)"))
 ((name . "hash-table-delete!")
  (signature lambda ((hash-table? hash-table) key ...) undefined)
  (desc . "This procedure removes any association to key in hash-table. It is not an error if no association for that key exists; in this case, nothing is done. Given a good hash function, this operation should have an (amortised) complexity of O(1) with respect to the number of associations in hash-table. (Note: this rules out implementation by association lists or fixed-length hash tables.)"))
 ((name . "hash-table-exists?")
  (signature lambda ((hash-table? hash-table) key) boolean?)
  (tags pure)
  (desc . "This predicate tells whether there is any association to key in hash-table. Given a good hash function, this operation should have an (amortised) complexity of O(1) with respect to the number of associations in hash-table. (Note: this rules out implementation by association lists or fixed-length hash tables.)"))
 ((name . "hash-table-update!")
  (signature
   case-lambda
   (((hash-table? hash-table) key (procedure? updater)) undefined)
   (((hash-table? hash-table) key (procedure? updater) (procedure? failure))
    undefined))
  (subsigs (updater (lambda (value) *)) (failure (lambda () *)))
  (desc . "Semantically equivalent to, but may be implemented more efficiently than, the following code:
        (hash-table-set! hash-table key
                         (updater (hash-table-ref hash-table key thunk)))"))
 ((name . "hash-table-update!/default")
  (signature lambda ((hash-table? hash-table) key (procedure? updater) default) undefined)
  (subsigs (updater (lambda (value) *)) (failure (lambda () *)))
  (desc . "Behaves as if it evaluates to (hash-table-update! hash-table key updater (lambda () default))"))
 ((name . "hash-table-size")
  (signature lambda ((hash-table? hash-table)) integer?)
  (tags pure)
  (desc . "Returns the number of associations in hash-table. This operation must have a complexity of O(1) with respect to the number of associations in hash-table."))
 ((name . "hash-table-keys")
  (signature lambda ((hash-table? hash-table)) list?)
  (tags pure)
  (desc . "Returns a list of keys in hash-table. The order of the keys is unspecified."))
 ((name . "hash-table-values")
  (signature lambda ((hash-table? hash-table)) list?)
  (tags pure)
  (desc . "Returns a list of values in hash-table. The order of the values is unspecified, and is not guaranteed to match the order of keys in the result of hash-table-keys."))
 ((name . "hash-table-walk")
  (signature lambda ((hash-table? hash-table) (procedure? proc)) undefined)
  (subsigs (proc (lambda (key value) undefined)))
  (desc . "proc should be a function taking two arguments, a key and a value. This procedure calls proc for each association in hash-table, giving the key of the association as key and the value of the association as value. The results of proc are discarded. The order in which proc is called for the different associations is unspecified.
(Note: in some implementations, there is a procedure called hash-table-map which does the same as this procedure. However, in other implementations, hash-table-map does something else. In no implementation that I know of, hash-table-map does a real functorial map that lifts an ordinary function to the domain of hash tables. Because of these reasons, hash-table-map is left outside this SRFI.)"))
 ((name . "hash-table-fold")
  (signature lambda ((hash-table? hash-table) (procedure? f) seed) *)
  (subsigs (f (lambda (key value state) *)))
  (tags pure)
  (desc . "This procedure calls f for every association in hash-table with three arguments: the key of the association key, the value of the association value, and an \"accumulated value\", val. val is init-value for the first invocation of f, and for subsequent invocations of f, the return value of the previous invocation of f. The value final-value returned by hash-table-fold is the return value of the last invocation of f. The order in which f is called for different associations is unspecified."))
 ((name . "hash-table->alist")
  (signature lambda ((hash-table? hash-table)) list?)
  (subsigs
    (return (alist key value)))
  (tags pure)
  (desc . "Returns an association list such that the car of each element in alist is a key in hash-table and the corresponding cdr of each element in alist is the value associated to the key in hash-table. The order of the elements is unspecified."))
 ((name . "hash-table-copy")
  (signature lambda ((hash-table? hash-table)) hash-table?)
  (tags pure)
  (desc . "Returns a new hash table with the same equivalence predicate, hash function and mappings as in hash-table."))
 ((name . "hash-table-merge!")
  (signature
   lambda
   ((hash-table? hash-table1) (hash-table? hash-table2))
   hash-table?)
  (desc . "Adds all mappings in hash-table2 into hash-table1 and returns the resulting hash table. This function may modify hash-table1 destructively."))
 ((name . "hash")
  (signature case-lambda ((obj) integer?) ((obj arg) integer?))
  (desc . "Produces a hash value for object in the range ( 0, bound (. If bound is not given, the implementation is free to choose any bound, given that the default bound is greater than the size of any imaginable hash table in a normal application. (This is so that the implementation may choose some very big value in fixnum range for the default bound.) This hash function is acceptable for equal?."))
 ((name . "string-hash")
  (signature
   case-lambda
   (((string? str)) integer?)
   (((string? str) arg) integer?))
  (tags pure)
  (desc . "The same as hash, except that the argument string must be a string."))
 ((name . "string-ci-hash")
  (signature
   case-lambda
   (((string? str)) integer?)
   (((string? str) arg) integer?))
  (tags pure)
  (desc . "The same as string-hash, except that the case of characters in string does not affect the hash value produced."))
 ((name . "hash-by-identity")
  (signature case-lambda ((obj) integer?) ((obj arg) integer?))
  (tags pure)
  (desc . "The same as hash, except that this function is only guaranteed to be acceptable for eq?. The reason for providing this function is that it might be implemented significantly more efficiently than hash. Implementations are encouraged to provide this function as a builtin.")))
