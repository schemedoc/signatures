(((name . "show")
  (signature
   case-lambda
   (((#f port) (formatter fmt) ...) string?)
   ((((or output-port? boolean?) port) (formatter fmt) ...) undefined))
  (desc . "The entry point for all formatting. Applies the fmt formatters in sequence, accumulating the output to output-dest. As with SRFI 28 format, output-dest can be an output port, #t to indicate the current output port, or #f to accumulate the output into a string and return that as the result of show."))
 ((name . "displayed") 
  (signature lambda (obj) formatter)
  (tags pure)
  (desc . "If obj is a formatter, returns obj as is. Otherwise, outputs obj using display semantics. Specifically, strings are output as if by write-string and characters are written as if by write-char. Other objects are output as with written (including nested strings and chars inside obj). This is the default behavior for top-level formats in show, each and most other high-level formatters."))
 ((name . "written") 
  (signature lambda (obj) formatter)
  (tags pure)
  (desc . "Outputs obj using write semantics. Uses the current numeric formatting settings to the extent that the written result can still be passed to read, possibly with loss of precision. Specifically, the current radix is used if set to any of 2, 8, 10 or 16, and the fixed point precision is used if specified and the radix is 10."))
 ((name . "written-simply") 
  (signature lambda (obj) formatter)
  (tags pure)
  (desc . "Same as \"written\", but doesn't handle shared structures. Infinite loops can still be avoided if used inside a formatter that truncates data (see trimmed and fitted below)."))
 ((name . "pretty")
  (signature lambda (obj) formatter)
  (tags pure)
  (desc . "Pretty-prints obj. The result should be identical to written except possibly for differences in whitespace to make the output resemble formatted source code. Implementations should print vectors and data lists (lists that don't begin with a (nested) symbol) in a tabular format when possible to reduce vertical space."))
 ((name . "pretty-simply") 
  (signature lambda (obj) formatter)
  (tags pure)
  (desc . "Same as \"pretty\", but doesn't handle shared structures. Infinite loops can still be avoided if used inside a formatter that truncates data (see trimmed and fitted below)."))
 ((name . "escaped")
  (signature
   case-lambda
   (((string? str)) formatter)
   (((string? str) (char? quote-ch)) formatter)
   (((string? str) (char? quote-ch) (char? esc-ch)) formatter)
   (((string? str) (char? quote-ch) (char? esc-ch) (procedure? renamer))
    formatter))
  (subsigs (renamer (lambda ((char? c)) char?)))
  (tags pure)
  (desc . "Outputs the string str, escaping any quote or escape characters. If esc-ch, which defaults to #\\\\, is #f, escapes only the quote-ch, which defaults to #\\\", by doubling it, as in SQL strings and CSV values. If renamer is provided, it should be a procedure of one character which maps that character to its escape value, e.g. #\\newline => #\\n, or #f if there is no escape value. "))
 ((name . "maybe-escaped")
  (signature
   case-lambda
   (((string? str) (procedure? pred)) formatter)
   (((string? str) (procedure? pred) (char? quote-ch)) formatter)
   (((string? str) (procedure? pred) (char? quote-ch) (char? esc-ch))
    formatter)
   (((string? str)
     (procedure? pred)
     (char? quote-ch)
     (char? esc-ch)
     (procedure? renamer))
    formatter))
  (subsigs
   (pred (lambda ((char? c)) boolean?))
   (renamer (lambda ((char? c)) char?)))
  (tags pure)
  (desc . "Like escaped, but first checks if any quoting is required (by the existence of either any quote or escape characters, or any character matching pred), and if so outputs the string in quotes and with escapes. Otherwise outputs the string as is. This is useful for quoting symbols and CSV output, etc."))
 ((name . "numeric")
  (signature
   case-lambda
   (((number? num)) formatter)
   (((number? num) (integer? radix)) formatter)
   (((number? num) (integer? radix) (integer? precision)) formatter)
   (((number? num)
     (integer? radix)
     (integer? precision)
     ((or boolean? pair?) sign))
    formatter)
   (((number? num)
     (integer? radix)
     (integer? precision)
     ((or boolean? pair?) sign)
     (integer? comma))
    formatter)
   (((number? num)
     (integer? radix)
     (integer? precision)
     ((or boolean? pair?) sign)
     (integer? comma)
     (char? comma-sep))
    formatter)
   (((number? num)
     (integer? radix)
     (integer? precision)
     ((or boolean? pair?) sign)
     (integer? comma)
     (char? comma-sep)
     (char? decimal-sep))
    formatter))
  (tags pure)
  (desc . "Formats a single number num. You can optionally specify any radix from 2 to 36 (even if num isn't an integer). precision forces a fixed-point format.
A sign of #t indicates to output a plus sign (+) for positive integers. However, if sign is a pair of two strings, it means to wrap negative numbers with the two strings. For example, (\"(\" . \")\") prints negative numbers in parentheses, financial style: -1.99 => (1.99).
comma is an integer specifying the number of digits between commas.
comma-sep is the character to use for commas, defaulting to #\\,.
decimal-sep is the character to use for decimals, defaulting to #\\., or to #\\, (European style) if comma-sep is already #\\..
These parameters may seem unwieldy, but they can also take their defaults from state variables"))
 ((name . "numeric/comma")
  (signature
   case-lambda
   (((number? num)) formatter)
   (((number? num) (integer? radix)) formatter)
   (((number? num) (integer? radix) (integer? precision)) formatter)
   (((number? num)
     (integer? radix)
     (integer? precision)
     ((or boolean? pair?) sign))
    formatter))
  (tags pure)
  (desc . "Shortcut for numeric to print with commas."))
 ((name . "numeric/si")
  (signature
   case-lambda
   (((number? num)) formatter)
   (((number? num) (integer? base)) formatter)
   (((number? num) (integer? base) (string? separator)) formatter))
  (tags pure)
  (desc . "Abbreviates num with an SI suffix as in the -h or --si option to many GNU commands. The base defaults to 1024, using suffix names like Ki, Mi, Gi, etc. Other bases (e.g. the standard 1000) have the suffixes k, M, G, etc. If separator is provided, it is inserted after the number, before any suffix."))
 ((name . "numeric/fitted")
  (signature
   case-lambda
   (((number? num)) formatter)
   (((number? num) (integer? radix)) formatter)
   (((number? num) (integer? radix) (integer? precision)) formatter)
   (((number? num)
     (integer? radix)
     (integer? precision)
     ((or boolean? pair?) sign))
    formatter)
   (((number? num)
     (integer? radix)
     (integer? precision)
     ((or boolean? pair?) sign)
     (integer? comma))
    formatter)
   (((number? num)
     (integer? radix)
     (integer? precision)
     ((or boolean? pair?) sign)
     (integer? comma)
     (char? comma-sep))
    formatter)
   (((number? num)
     (integer? radix)
     (integer? precision)
     ((or boolean? pair?) sign)
     (integer? comma)
     (char? comma-sep)
     (char? decimal-sep))
    formatter))
  (tags pure)
  (desc . "Like numeric, but if the result doesn't fit in width using the current precision, output instead a string of hashes rather than showing an incorrectly truncated number."))
 ((name . "nl") 
  (signature value formatter)
  (desc . "Outputs a newline."))
 ((name . "fl") 
  (signature value formatter)
  (desc . "Short for \"fresh line,\" outputs a newline only if we're not already at the start of a line."))
 ((name . "space-to")
  (signature lambda ((integer? column)) formatter)
  (tags pure)
  (desc . "Outputs spaces up to the given column. If the current column is already >= column, does nothing. The character used for spacing is the current value of pad-char, described below, which defaults to space. Columns are zero-based."))
 ((name . "tab-to")
  (signature case-lambda (() formatter) (((integer? tab-width)) formatter))
  (tags pure)
  (desc . "Outputs spaces up to the next tab stop, using tab stops of width tab-width, which defaults to 8. If already on a tab stop, does nothing. If you want to ensure you always tab at least one space, you can use (each \" \" (tab-to width)). Columns are zero-based."))
 ((name . "nothing") 
  (signature value formatter)
  (desc . "Outputs nothing (useful in combinators and as a default noop in conditionals)."))
 ((name . "each")
  (signature lambda ((formatter fmt) ...) formatter)
  (tags pure)
  (desc . "Applies each fmt in sequence, as in the top-level of show."))
 ((name . "each-in-list")
  (signature lambda ((list? list-of-fmts)) formatter)
  (tags pure)
  (desc . "Equivalent to (apply each list-of-fmts) but may be more efficient."))
 ((name . "joined")
  (signature
   case-lambda
   (((procedure? mapper) (list? list)) formatter)
   (((procedure? mapper) (list? list) ((or string? formatter) separator))
    formatter))
  (subsigs (mapper (lambda (element) formatter)))
  (tags pure)
  (desc . "Formats each element elt of list with (mapper elt), inserting sep in between. sep defaults to the empty string, but can be any format or string."))
 ((name . "joined/prefix")
  (signature
   case-lambda
   (((procedure? mapper) (list? list)) formatter)
   (((procedure? mapper) (list? list) ((or string? formatter) separator))
    formatter))
  (subsigs (mapper (lambda (element) formatter)))
  (tags pure)
  (desc . "As joined, but inserts sep before every element."))
 ((name . "joined/suffix")
  (signature
   case-lambda
   (((procedure? mapper) (list? list)) formatter)
   (((procedure? mapper) (list? list) ((or string? formatter) separator))
    formatter))
  (subsigs (mapper (lambda (element) formatter)))
  (tags pure)
  (desc . "As joined, but inserts sep after every element."))
 ((name . "joined/last")
  (signature
   case-lambda
   (((procedure? mapper) (procedure? last-mapper) (list? list)) formatter)
   (((procedure? mapper)
     (procedure? last-mapper)
     (list? list)
     ((or string? formatter) separator))
    formatter))
  (subsigs
   (mapper (lambda (element) formatter))
   (last-mapper (lambda (element) formatter)))
  (tags pure)
  (desc . "As joined, but the last element of the list is formatted with last-mapper instead."))
 ((name . "joined/dot")
  (signature
   case-lambda
   (((procedure? mapper)
     (procedure? dot-mapper)
     ((or list? dotted-list?) list))
    formatter)
   (((procedure? mapper)
     (procedure? dot-mapper)
     ((or list? dotted-list?) list)
     ((or string? formatter) separator))
    formatter))
  (subsigs
   (mapper (lambda (element) formatter))
   (dot-mapper (lambda (tail) formatter)))
  (tags pure)
  (desc . "As joined, but if the list is a dotted list, then formats the dotted value with dot-mapper instead."))
 ((name . "joined/range")
  (signature
   case-lambda
   (((procedure? mapper) (integer? start)) formatter)
   (((procedure? mapper) (integer? start) ((or integer? #f) end)) formatter)
   (((procedure? mapper)
     (integer? start)
     ((or integer? #f) end)
     ((or string? formatter) separator))
    formatter))
  (subsigs (mapper (lambda ((integer? value)) formatter)))
  (tags pure)
  (desc . "As joined, but counts from start (inclusive) to end (exclusive), formatting each integer in the range with mapper. If end is #f or unspecified, produces an infinite stream of output."))
 ((name . "padded")
  (signature lambda ((integer? width) (formatter fmt) ...) formatter)
  (tags pure)
  (desc . "Add extra space to the left side of the output generated by the fmts to pad it to width."))
 ((name . "padded/right")
  (signature lambda ((integer? width) (formatter fmt) ...) formatter)
  (tags pure)
  (desc . "Add extra space to the right side of the output generated by the fmts to pad it to width."))
 ((name . "padded/both")
  (signature lambda ((integer? width) (formatter fmt) ...) formatter)
  (tags pure)
  (desc . "Add extra space to the both sides of the output generated by the fmts to pad it to width."))
 ((name . "trimmed")
  (signature lambda ((integer? width) (formatter fmt) ...) formatter)
  (tags pure)
  (desc . "Truncates the output of the fmts to force it in under width columns. As soon as any of the fmts exceeds width, stop formatting and truncate the result, returning control to whoever called trimmed. If a truncation ellipsis is set, then when any truncation occurs trimmed will prepend the ellipsis."))
 ((name . "trimmed/right")
  (signature lambda ((integer? width) (formatter fmt) ...) formatter)
  (tags pure)
  (desc . "Truncates the output of the fmts to force it in under width columns. As soon as any of the fmts exceeds width, stop formatting and truncate the result, returning control to whoever called trimmed. If a truncation ellipsis is set, then when any truncation occurs trimmed/right will append the ellipsis."))
 ((name . "trimmed/both")
  (signature lambda ((integer? width) (formatter fmt) ...) formatter)
  (tags pure)
  (desc . "Truncates the output of the fmts to force it in under width columns. As soon as any of the fmts exceeds width, stop formatting and truncate the result, returning control to whoever called trimmed. If a truncation ellipsis is set, then when any truncation occurs trimmed/bith will both prepend and append the ellipsis."))
 ((name . "trimmed/lazy")
  (signature lambda ((integer? width) (formatter fmt) ...) formatter)
  (tags pure)
  (desc . "A variant of trimmed which generates each fmt in left to right order, and truncates and terminates immediately if more than width characters are generated. Thus this is safe to use with an infinite amount of output, e.g. from written-simply on an infinite list."))
 ((name . "fitted")
  (signature lambda ((integer? width) (formatter fmt) ...) formatter)
  (tags pure)
  (desc . "A combination of padded and trimmed that ensures that the output width is exactly width, truncating if it goes over and padding if it goes under."))
 ((name . "fitted/right")
  (signature lambda ((integer? width) (formatter fmt) ...) formatter)
  (tags pure)
  (desc . "A combination of padded and trimmed that ensures that the output width is exactly width, truncating if it goes over and padding if it goes under."))
 ((name . "fitted/both")
  (signature lambda ((integer? width) (formatter fmt) ...) formatter)
  (tags pure)
  (desc . "A combination of padded and trimmed that ensures that the output width is exactly width, truncating if it goes over and padding if it goes under."))
 ((name . "columnar")
  (signature
   lambda
   (((or formatter string? symbol? number?) column) ...)
   formatter)
  (tags pure)
  (desc . "Formats each column side-by-side, i.e. as though each were formatted separately and then the individual lines concatenated together. The current line width (from the width state variable) is divided evenly among the columns, and all but the last column are right-padded.
You may also prefix any column with any of the symbols 'left, 'right or 'center to control the justification. The symbol 'infinite can be used to indicate the column generates an infinite stream of output.
You can further prefix any column with a width modifier. Any positive integer is treated as a fixed width, ignoring the available width. Any real number between 0 and 1 indicates a fraction of the available width (after subtracting out any fixed widths). Columns with unspecified width divide up the remaining width evenly. If the extra space does not divide evenly, it is allocated column-wise left to right, e.g. if the width of 78 is divided among 5 columns, the column widths become 16, 16, 16, 15, 15 in order.
Note that columnar builds its output incrementally, interleaving calls to the generators until each has produced a line, then concatenating that line together and outputting it. This is important because as noted above, some columns may produce an infinite stream of output, and in general you may want to format data larger than can fit into memory. Thus columnar would be suitable for line numbering a file of arbitrary size, or implementing the Unix yes(1) command, etc."))
 ((name . "tabular")
  (signature
   lambda
   (((or formatter string? symbol? number?) column) ...)
   formatter)
  (tags pure)
  (desc . "Equivalent to columnar except that each column is padded at least to the minimum width required on any of its lines.
This makes it easier to generate tables without knowing widths in advance. However, because it requires generating the entire output in advance to determine the correct column widths, tabular cannot format a table larger than would fit in memory."))
 ((name . "wrapped")
  (signature lambda ((formatter fmt) ...) formatter)
  (tags pure)
  (desc . "Behaves like each, except text is accumulated and lines are wrapped to fit in the current width as in the Unix fmt(1) command. Specifically, words are tokenized by splitting on all characters which satisfy the predicate in the parameter word-separator?, which defaults to char-whitespace?. Words are grouped into lines separating them by space, and line breaks are introduced to minimize the sum of the cube of trailing whitespace on every line."))
 ((name . "wrapped/list")
  (signature lambda ((list? list-of-strings) ...) formatter)
  (tags pure)
  (desc . "Like wrapped, but taking a pre-tokenized list of strings."))
 ((name . "wrapped/char")
  (signature lambda ((formatter fmt) ...) formatter)
  (tags pure)
  (desc . "As wrapped, but splits simply on individual characters exactly as the current width is reached on each line. Thus there is nothing to optimize and this formatter doesn't buffer output."))
 ((name . "justified")
  (signature lambda ((formatter fmt) ...) formatter)
  (tags pure)
  (desc . "Like wrapped except the lines are full-justified."))
 ((name . "from-file") 
  (signature lambda ((string? pathname)) formatter)
  (desc . "Displays the contents of the file pathname one line at a time, so that in typical formatters such as columnar only constant memory is consumed, making this suitable for formatting files of arbitrary size."))
 ((name . "line-numbers")
  (signature case-lambda (() formatter) (((integer? start)) formatter))
  (tags pure)
  (desc . "A convenience utility, just formats an infinite stream of numbers (in the current radix) beginning with start, which defaults to 1."))
 ((name . "as-red") (signature lambda ((formatter fmt) ...) formatter) (desc . "Outputs the formatters colored or (boldened or underline) with ANSI escapes, for use when formatting to a terminal."))
 ((name . "as-blue") (signature lambda ((formatter fmt) ...) formatter) (desc . "Outputs the formatters colored or (boldened or underline) with ANSI escapes, for use when formatting to a terminal."))
 ((name . "as-green") (signature lambda ((formatter fmt) ...) formatter) (desc . "Outputs the formatters colored or (boldened or underline) with ANSI escapes, for use when formatting to a terminal."))
 ((name . "as-cyan") (signature lambda ((formatter fmt) ...) formatter) (desc . "Outputs the formatters colored or (boldened or underline) with ANSI escapes, for use when formatting to a terminal."))
 ((name . "as-yellow") (signature lambda ((formatter fmt) ...) formatter) (desc . "Outputs the formatters colored or (boldened or underline) with ANSI escapes, for use when formatting to a terminal."))
 ((name . "as-magenta") (signature lambda ((formatter fmt) ...) formatter) (desc . "Outputs the formatters colored or (boldened or underline) with ANSI escapes, for use when formatting to a terminal."))
 ((name . "as-white") (signature lambda ((formatter fmt) ...) formatter) (desc . "Outputs the formatters colored or (boldened or underline) with ANSI escapes, for use when formatting to a terminal."))
 ((name . "as-black") (signature lambda ((formatter fmt) ...) formatter) (desc . "Outputs the formatters colored or (boldened or underline) with ANSI escapes, for use when formatting to a terminal."))
 ((name . "as-bold") (signature lambda ((formatter fmt) ...) formatter) (desc . "Outputs the formatters colored or (boldened or underline) with ANSI escapes, for use when formatting to a terminal."))
 ((name . "as-underline") (signature lambda ((formatter fmt) ...) formatter) (desc . "Outputs the formatters colored or (boldened or underline) with ANSI escapes, for use when formatting to a terminal."))
 ((name . "as-unicode") (signature lambda ((formatter fmt) ...) formatter) (desc . "Padding, trimming and tabbing, etc. will generally not do the right thing in the presence of zero-width and double-width Unicode characters. This formatter overrides the string-width state var used in column tracking to do the right thing in such cases, considering Unicode double or full width characters as 2 characters wide (as they typically are in fixed-width terminals), while treating combining and non-spacing characters as 0 characters wide."))
 ((name . "unicode-terminal-width")
  (signature lambda ((string? str)) integer?)
  (tags pure)
  (desc . "A utility function which returns the integer number of columns str would require in a terminal"))
 ((name . "fn")
  (signature syntax-rules () ((_ (binding ...) expr ... fmt) formatter))
  (subsigs
   (binding (pattern (id state-var) id))
   (state-var (value formatter-variable)))
  (desc . "Short for \"function,\" this is the analog to lambda. Returns a formatter which on application evaluates each expr and fmt in left-to-right order, in a lexical environment extended with each identifier id bound to the current value of the state variable named by the symbol state-var. The result of the fmt is then applied as a formatter. "))
 ((name . "with")
  (signature syntax-rules () ((_ ((state-var value) ...) fmt ...)))
  (subsigs (state-var (value formatter-variable)))
  (desc . "Conceptually the formatting equivalent of parameterize, temporarily altering state variables. Applies each of the formatters fmt with each state-var bound to the corresponding value. The resulting state is then updated to restore each state-var to its original value."))
 ((name . "with!")
  (signature syntax-rules () ((_ (state-var value) ...)))
  (subsigs (state-var (value formatter-variable)))
  (desc . "Similar to with but does not restore the original values, changing the value of each state-var for any remaining formatters in a sequence."))
 ((name . "forked")
  (signature lambda ((formatter fmt1) (formatter fmt2)) formatter)
  (tags pure)
  (desc . "Calls fmt1 on (a conceptual copy of) the current state, then fmt2 on the same original state as though fmt1 had not been called."))
 ((name . "call-with-output")
  (signature lambda ((formatter fmt) (procedure? mapper)) formatter)
  (subsigs (mapper (lambda ((string? result-string)) formatter)))
  (tags pure)
  (desc . "A utility, calls formatter on a copy of the current state (as with forked), accumulating the results into a string. Then calls the formatter resulting from (mapper result-string) on the original state."))
 ((name . "port") (signature value formatter-variable) (desc . "The textual port output is written to, this can be overridden to capture intermediate output."))
 ((name . "row") (signature value formatter-variable) (desc . "The current row of output."))
 ((name . "col") (signature value formatter-variable) (desc . "The current column of output, used for padding and spacing, etc."))
 ((name . "width") (signature value formatter-variable) (desc . "The current line width, used for wrapping, pretty-printing, and columnar formatting. The default is implementation-defined."))
 ((name . "output") (signature value formatter-variable) (desc . "The underlying standard formatter for writing a single string. The default value outputs the string while tracking the current row and col. This can be overridden both to capture intermediate output and perform transformations on strings before outputting, but should generally wrap the existing output to preserve expected behavior."))
 ((name . "writer") (signature value formatter-variable) (desc . "The mapper for automatic formatting of non-string/char values in top-level show, each and other formatters. Default value is implementation-defined."))
 ((name . "string-width") (signature value formatter-variable) (desc . "A function of a single string, it returns the length in columns of that string, used by the default output."))
 ((name . "pad-char") (signature value formatter-variable) (desc . "The character used by space-to, tab-to and other padding formatters."))
 ((name . "ellipsis") (signature value formatter-variable) (desc . "The string used when truncating as described in trimmed."))
 ((name . "radix") (signature value formatter-variable) (desc . "The radix for numeric output, defaulting to 10, as used in numeric and written."))
 ((name . "precision") (signature value formatter-variable) (desc . "The precision for numeric output, as described in numeric and written. The precision specifies the number of digits written after the decimal point. If the numeric value to be written out requires more digits to represent it than precision, the written representation is chosen which is closest to the numeric value and representable with the specified precision. If the numeric value falls on the midpoint of two such representations, it is implementation dependent which representation is chosen.
When the numeric value is an inexact floating-point number, there is more than one interpretation of this \"rounding\". One is to take the effective value the floating-point number represents (e.g. if we use binary floating-point numbers, we take the value of (* sign mantissa (expt 2 exponent))), and compare it to the two closest numeric representations of the given precision. Another way is to obtain the default notation of the floating-point number and apply rounding to it. The former (we call it effective rounding) is consistent with most floating-point number operations, but may lead to a more non-intuitive result than the latter (we call it notational rounding). For example, 5.015 can't be represented exactly in binary floating-point numbers. With IEEE754 floating-point numbers, the floating point number closest to 5.015 is smaller than exact 5.015, i.e. (< 5.015 5015/1000) => #t. With effective rounding with precision 2, it should result in \"5.01\". However, users who look at the notation may be confused by \"5.015\" not being rounded up as they usually expect. With notational rounding the implementation chooses \"5.02\" (if it also adopts round-half-to-infinity or round-half-up rule). It is up to the implementation to choose which interpretation to adopt. "))
 ((name . "decimal-sep") (signature value formatter-variable) (desc . "The decimal separator for floating point output, default \".\"."))
 ((name . "decimal-align") (signature value formatter-variable) (desc . "Specifies an alignment for the decimal place when formatting numbers, and is useful for outputting tables of numbers."))
 ((name . "word-separator?") (signature value formatter-variable) (desc . "A character predicate used to tokenize words for wrapped and justify. Defaults to char-whitespace?. More flexibility is available with wrapped/list.")))
