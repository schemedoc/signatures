(((name . "set")
  (signature lambda ((comparator? comparator) element ...) set?)
  (tags pure)
  (desc . "Returns a newly allocated empty set. The comparator argument is a SRFI 114 comparator, which is used to control and distinguish the elements of the set. The elements are used to initialize the set."))
 ((name . "set-unfold")
  (signature
   lambda
   ((comparator? comparator)
    (procedure? stop?)
    (procedure? mapper)
    (procedure? successor)
    seed)
   set?)
  (subsigs
   (stop? (lambda (seed) boolean?))
   (mapper (lambda (seed) *))
   (successor (lambda (seed) *)))
  (tags pure)
  (desc . "Create a newly allocated set as if by set using comparator. If the result of applying the predicate stop? to seed is true, return the set. Otherwise, apply the procedure mapper to seed. The value that mapper returns is added to the set. Then get a new seed by applying the procedure successor to seed, and repeat this algorithm."))
 ((name . "set?") 
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "Returns #t if obj is a set, and #f otherwise."))
 ((name . "set-contains?")
  (signature lambda ((set? set) element) boolean?)
  (tags pure)
  (desc . "Returns #t if element is a member of set and #f otherwise."))
 ((name . "set-empty?") 
  (signature lambda ((set? set)) boolean?)
  (tags pure)
  (desc . "Returns #t if set has no elements and #f otherwise."))
 ((name . "set-disjoint?")
  (signature lambda ((set? set1) (set? set2)) boolean?)
  (tags pure)
  (desc . "Returns #t if set1 and set2 have no elements in common and #f otherwise."))
 ((name . "set-member")
  (signature lambda ((set? set) element default) *)
  (tags pure)
  (desc . "Returns the element of set that is equal, in the sense of set's equality predicate, to element. If element is not a member of set, default is returned."))
 ((name . "set-element-comparator")
  (signature lambda ((set? set)) comparator?)
  (tags pure)
  (desc . "Returns the comparator used to compare the elements of set."))
 ((name . "set-adjoin")
  (signature lambda ((set? set) element ...) set?)
  (tags pure)
  (desc . "The set-adjoin procedure returns a newly allocated set that uses the same comparator as set and contains all the values of set, and in addition each element unless it is already equal (in the sense of the comparator) to one of the existing or newly added members. It is an error to add an element to set that does not return #t when passed to the type test procedure of the comparator."))
 ((name . "set-adjoin!") 
  (signature lambda ((set? set) element ...) set?)
  (desc . "The set-adjoin! procedure is the same as set-adjoin, except that it is permitted to mutate and return the set argument rather than allocating a new set."))
 ((name . "set-replace")
  (signature lambda ((set? set) element) set?)
  (tags pure)
  (desc . "The set-replace procedure returns a newly allocated set that uses the same comparator as set and contains all the values of set except as follows: If element is equal (in the sense of set's comparator) to an existing member of set, then that member is omitted and replaced by element. If there is no such element in set, then set is returned unchanged."))
 ((name . "set-replace!") 
  (signature lambda ((set? set) element) set?)
  (desc . "The set-replace! procedure is the same as set-replace, except that it is permitted to mutate and return the set argument rather than allocating a new set."))
 ((name . "set-delete")
  (signature lambda ((set? set) element ...) set?)
  (tags pure)
  (desc . "The set-delete procedure returns a newly allocated set containing all the values of set except for any that are equal (in the sense of set's comparator) to one or more of the elements. Any element that is not equal to some member of the set is ignored."))
 ((name . "set-delete!") 
  (signature lambda ((set? set) element ...) set?)
  (desc . "The set-delete! procedure is the same as set-delete, except that it is permitted to mutate and return the set argument rather than allocating a new set."))
 ((name . "set-delete-all")
  (signature lambda ((set? set) (list? elements)) set?)
  (tags pure)
  (desc . "The set-delete-all procedure is the same as set-delete, except that it accepts a single argument which is a list of elements to be deleted."))
 ((name . "set-delete-all!")
  (signature lambda ((set? set) (list? elements)) set?)
  (desc . "The set-delete-all! procedure is the same as set-delete!, except that it accepts a single argument which is a list of elements to be deleted."))
 ((name . "set-search!")
  (signature
   lambda
   ((set? set) element (procedure? failure) (procedure? success))
   (values set? *))
  (subsigs
   (failure (lambda ((procedure? insert) (procedure? ignore)) *))
   (insert (lambda (obj) *))
   (ignore (lambda (obj) *))
   (success (lambda (element (procedure? update) (procedure? remove)) *))
   (update (lambda (new-element obj) *))
   (remove (lambda (obj) *)))
  (desc . "The set is searched for element. If it is not found, then the failure procedure is tail-called with two continuation arguments, insert and ignore, and is expected to tail-call one of them. If element is found, then the success procedure is tail-called with the matching element of set and two continuations, update and remove, and is expected to tail-call one of them. The effects of the continuations are as follows (where obj is any Scheme object):
* Invoking (insert obj) causes element to be inserted into set.
* Invoking (ignore obj) causes set to remain unchanged.
* Invoking (update new-element obj) causes new-element to be inserted into set in place of element.
* Invoking (remove obj) causes the matching element of set to be removed from it.

In all cases, two values are returned: the possibly updated set and obj."))
 ((name . "set-size")
  (signature lambda ((set? set)) integer?)
  (tags pure)
  (desc . "Returns the number of elements in set as an exact integer. "))
 ((name . "set-find")
  (signature lambda ((procedure? predicate) (set? set) (procedure? failure)) *)
  (subsigs (predicate (lambda (obj) boolean?)) (failure (lambda () *)))
  (tags pure)
  (desc . "Returns an arbitrarily chosen element of set that satisfies predicate, or the result of invoking failure with no arguments if there is none."))
 ((name . "set-count")
  (signature lambda ((procedure? predicate) (set? set)) integer?)
  (subsigs (predicate (lambda (obj) boolean?)))
  (tags pure)
  (desc . "Returns the number of elements of set that satisfy predicate as an exact integer."))
 ((name . "set-any?")
  (signature lambda ((procedure? predicate) (set? set)) boolean?)
  (subsigs (predicate (lambda (obj) boolean?)))
  (tags pure)
  (desc . "Returns #t if any element of set satisfies predicate, or #f otherwise. Note that this differs from the SRFI 1 analogue because it does not return an element of the set."))
 ((name . "set-every?")
  (signature lambda ((procedure? predicate) (set? set)) boolean?)
  (subsigs (predicate (lambda (obj) boolean?)))
  (tags pure)
  (desc . "Returns #t if every element of set satisfies predicate, or #f otherwise. Note that this differs from the SRFI 1 analogue because it does not return an element of the set. "))
 ((name . "set-map")
  (signature lambda ((comparator? comparator) (procedure? proc) (set? set)) *)
  (subsigs (proc (lambda (obj) *)))
  (tags pure)
  (desc . "Applies proc to each element of set in arbitrary order and returns a newly allocated set, created as if by (set comparator), which contains the results of the applications. For example:
(set-map string-ci-comparator symbol->string (set eq? 'foo 'bar 'baz)) => (set string-ci-comparator \"foo\" \"bar\" \"baz\")
Note that, when proc defines a mapping that is not 1:1, some of the mapped objects may be equivalent in the sense of comparator's equality predicate, and in this case duplicate elements are omitted as in the set constructor."))
 ((name . "set-for-each")
  (signature lambda ((procedure? proc) (set? set)) undefined)
  (subsigs (proc (lambda (obj) undefined)))
  (desc . "Applies proc to set in arbitrary order, discarding the returned values. Returns an unspecified result."))
 ((name . "set-fold")
  (signature lambda ((procedure? proc) nil (set? set)) *)
  (subsigs (proc (lambda (obj state) *)))
  (tags pure)
  (desc . "Invokes proc on each member of set in arbitrary order, passing the result of the previous invocation as a second argument. For the first invocation, nil is used as the second argument. Returns the result of the last invocation, or nil if there was no invocation."))
 ((name . "set-filter")
  (signature lambda ((procedure? predicate) (set? set)) set?)
  (subsigs (predicate (lambda (obj) *)))
  (tags pure)
  (desc . "Returns a newly allocated set with the same comparator as set, containing just the elements of set that satisfy predicate."))
 ((name . "set-filter!")
  (signature lambda ((procedure? predicate) (set? set)) set?)
  (subsigs (predicate (lambda (obj) *)))
  (desc . "A linear update procedure that returns a set containing just the elements of set that satisfy predicate."))
 ((name . "set-remove")
  (signature lambda ((procedure? predicate) (set? set)) set?)
  (subsigs (predicate (lambda (obj) *)))
  (tags pure)
  (desc . "Returns a newly allocated set with the same comparator as set, containing just the elements of set that do not satisfy predicate."))
 ((name . "set-remove!")
  (signature lambda ((procedure? predicate) (set? set)) set?)
  (subsigs (predicate (lambda (obj) *)))
  (desc . "A linear update procedure that returns a set containing just the elements of set that do not satisfy predicate."))
 ((name . "set-partition")
  (signature lambda ((procedure? predicate) (set? set)) (values set? set?))
  (subsigs (predicate (lambda (obj) *)))
  (tags pure)
  (desc . "Returns two values: a newly allocated set with the same comparator as set that contains just the elements of set that satisfy predicate, and another newly allocated set, also with the same comparator, that contains just the elements of set that do not satisfy predicate."))
 ((name . "set-partition!")
  (signature lambda ((procedure? predicate) (set? set)) (values set? set?))
  (subsigs (predicate (lambda (obj) *)))
  (desc . "A linear update procedure that returns two sets containing the elements of set that do and do not, respectively, not satisfy predicate."))
 ((name . "set-copy") 
  (signature lambda ((set? set)) set?)
  (tags pure)
  (desc . "Returns a newly allocated set containing the elements of set, and using the same comparator."))
 ((name . "set->list") 
  (signature lambda ((set? set)) list?)
  (desc . "Returns a newly allocated list containing the members of set in unspecified order."))
 ((name . "list->set")
  (signature lambda ((comparator? comparator) (list? list)) set?)
  (tags pure)
  (desc . "Returns a newly allocated set, created as if by set using comparator, that contains the elements of list. Duplicate elements (in the sense of the equality predicate) are omitted."))
 ((name . "list->set!") 
  (signature lambda ((set? set) (list? list)) set?)
  (desc . "Returns a set that contains the elements of both set and list. Duplicate elements (in the sense of the equality predicate) are omitted."))
 ((name . "set=?")
  (signature lambda ((set? set1) (set? set2) ...) boolean?)
  (tags pure)
  (desc . "Returns #t if each set contains the same elements."))
 ((name . "set<?")
  (signature lambda ((set? set1) (set? set2) ...) boolean?)
  (tags pure)
  (desc . "Returns #t if each set other than the last is a proper subset of the following set, and #f otherwise."))
 ((name . "set>?")
  (signature lambda ((set? set1) (set? set2) ...) boolean?)
  (tags pure)
  (desc . "Returns #t if each set other than the last is a proper superset of the following set, and #f otherwise."))
 ((name . "set<=?")
  (signature lambda ((set? set1) (set? set2) ...) boolean?)
  (tags pure)
  (desc . "Returns #t if each set other than the last is a subset of the following set, and #f otherwise."))
 ((name . "set>=?")
  (signature lambda ((set? set1) (set? set2) ...) boolean?)
  (tags pure)
  (desc . "Returns #t if each set other than the last is a superset of the following set, and #f otherwise."))
 ((name . "set-union")
  (signature lambda ((set? set1) (set? set2) ...) set?)
  (tags pure)
  (desc . "Return a newly allocated set that is the union of the sets."))
 ((name . "set-intersection")
  (signature lambda ((set? set1) (set? set2) ...) set?)
  (tags pure)
  (desc . "Return a newly allocated set that is the intersection of the sets."))
 ((name . "set-difference")
  (signature lambda ((set? set1) (set? set2) ...) set?)
  (tags pure)
  (desc . "Return a newly allocated set that is the asymmetric difference of the sets. Asymmetric difference is extended to more than two sets by taking the difference between the first set and the union of the others."))
 ((name . "set-xor")
  (signature lambda ((set? set1) (set? set2)) set?)
  (tags pure)
  (desc . "Return a newly allocated set that is the symmetric difference of the sets. Symmetric difference is not extended beyond two sets. Elements in the result set are drawn from the first set in which they appear."))
 ((name . "set-union!")
  (signature lambda ((set? set1) (set? set2) ...) set?)
  (desc . "Linear update returning a set that is the union of the sets."))
 ((name . "set-intersection!")
  (signature lambda ((set? set1) (set? set2) ...) set?)
  (desc . "Linear update returning a set that is the intersection of the sets."))
 ((name . "set-difference!")
  (signature lambda ((set? set1) (set? set2) ...) set?)
  (desc . "Linear update returning a set that is the asymmetric difference of the sets. Asymmetric difference is extended to more than two sets by taking the difference between the first set and the union of the others."))
 ((name . "set-xor!")
  (signature lambda ((set? set1) (set? set2)) set?)
  (desc . "Linear update returning a set that is the symmetric difference of the sets. Symmetric difference is not extended beyond two sets. Elements in the result set are drawn from the first set in which they appear."))
 ((name . "bag")
  (signature lambda ((comparator? comparator) element ...) bag?)
  (tags pure)
  (desc . "Returns a newly allocated empty bag. The comparator argument is a SRFI 114 comparator, which is used to control and distinguish the elements of the bag. The elements are used to initialize the bag."))
 ((name . "bag-unfold")
  (signature
   lambda
   ((comparator? comparator)
    (procedure? stop?)
    (procedure? mapper)
    (procedure? successor)
    seed)
   bag?)
  (subsigs
   (stop? (lambda (seed) boolean?))
   (mapper (lambda (seed) *))
   (successor (lambda (seed) *)))
  (tags pure)
  (desc . "Create a newly allocated bag as if by bag using comparator. If the result of applying the predicate stop? to seed is true, return the bag. Otherwise, apply the procedure mapper to seed. The value that mapper returns is added to the bag. Then get a new seed by applying the procedure successor to seed, and repeat this algorithm."))
 ((name . "bag?") 
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "Returns #t if obj is a bag, and #f otherwise."))
 ((name . "bag-contains?")
  (signature lambda ((bag? bag) element) boolean?)
  (tags pure)
  (desc . "Returns #t if element is a member of bag and #f otherwise."))
 ((name . "bag-empty?") 
  (signature lambda ((bag? bag)) boolean?)
  (tags pure)
  (desc . "Returns #t if bag has no elements and #f otherwise."))
 ((name . "bag-disjoint?")
  (signature lambda ((bag? bag1) (bag? bag2)) boolean?)
  (tags pure)
  (desc . "Returns #t if bag1 and bag2 have no elements in common and #f otherwise."))
 ((name . "bag-member")
  (signature lambda ((bag? bag) element default) *)
  (tags pure)
  (desc . "Returns the element of bag that is equal, in the sense of bag's equality predicate, to element. If element is not a member of bag, default is returned."))
 ((name . "bag-element-comparator")
  (signature lambda ((bag? bag)) comparator?)
  (tags pure)
  (desc . "Returns the comparator used to compare the elements of bag."))
 ((name . "bag-adjoin")
  (signature lambda ((bag? bag) element ...) bag?)
  (tags pure)
  (desc . "The bag-adjoin procedure returns a newly allocated bag that uses the same comparator as bag and contains all the values of bag, and in addition each element unless it is already equal (in the sense of the comparator) to one of the existing or newly added members. It is an error to add an element to bag that does not return #t when passed to the type test procedure of the comparator."))
 ((name . "bag-adjoin!") 
  (signature lambda ((bag? bag) element ...) bag?)
  (desc . "The bag-adjoin! procedure is the same as bag-adjoin, except that it is permitted to mutate and return the bag argument rather than allocating a new bag."))
 ((name . "bag-replace")
  (signature lambda ((bag? bag) element) bag?)
  (tags pure)
  (desc . "The bag-replace procedure returns a newly allocated bag that uses the same comparator as bag and contains all the values of bag except as follows: If element is equal (in the sense of bag's comparator) to an existing member of bag, then that member is omitted and replaced by element. If there is no such element in bag, then bag is returned unchanged."))
 ((name . "bag-replace!") 
  (signature lambda ((bag? bag) element) bag?)
  (desc . "The bag-replace! procedure is the same as bag-replace, except that it is permitted to mutate and return the bag argument rather than allocating a new bag."))
 ((name . "bag-delete")
  (signature lambda ((bag? bag) element ...) bag?)
  (tags pure)
  (desc . "The bag-delete procedure returns a newly allocated bag containing all the values of bag except for any that are equal (in the sense of bag's comparator) to one or more of the elements. Any element that is not equal to some member of the bag is ignored."))
 ((name . "bag-delete!") 
  (signature lambda ((bag? bag) element ...) bag?)
  (desc . "The bag-delete! procedure is the same as bag-delete, except that it is permitted to mutate and return the bag argument rather than allocating a new bag."))
 ((name . "bag-delete-all")
  (signature lambda ((bag? bag) (list? elements)) bag?)
  (tags pure)
  (desc . "The bag-delete-all procedure is the same as bag-delete, except that it accepts a single argument which is a list of elements to be deleted."))
 ((name . "bag-delete-all!")
  (signature lambda ((bag? bag) (list? elements)) bag?)
  (desc . "The bag-delete-all! procedure is the same as bag-delete!, except that it accepts a single argument which is a list of elements to be deleted."))
 ((name . "bag-search!")
  (signature
   lambda
   ((bag? bag) element (procedure? failure) (procedure? success))
   (values bag? *))
  (subsigs
   (failure (lambda ((procedure? insert) (procedure? ignore)) *))
   (insert (lambda (obj) *))
   (ignore (lambda (obj) *))
   (success (lambda (element (procedure? update) (procedure? remove)) *))
   (update (lambda (new-element obj) *))
   (remove (lambda (obj) *)))
  (desc . "The bag is searched for element. If it is not found, then the failure procedure is tail-called with two continuation arguments, insert and ignore, and is expected to tail-call one of them. If element is found, then the success procedure is tail-called with the matching element of bag and two continuations, update and remove, and is expected to tail-call one of them. The effects of the continuations are as follows (where obj is any Scheme object):
* Invoking (insert obj) causes element to be inserted into bag.
* Invoking (ignore obj) causes bag to remain unchanged.
* Invoking (update new-element obj) causes new-element to be inserted into bag in place of element.
* Invoking (remove obj) causes the matching element of bag to be removed from it.

In all cases, two values are returned: the possibly updated bag and obj."))
 ((name . "bag-size")
  (signature lambda ((bag? bag)) integer?)
  (tags pure)
  (desc . "Returns the number of elements in bag as an exact integer. "))
 ((name . "bag-find")
  (signature lambda ((procedure? predicate) (bag? bag) (procedure? failure)) *)
  (subsigs (predicate (lambda (obj) boolean?)) (failure (lambda () *)))
  (tags pure)
  (desc . "Returns an arbitrarily chosen element of bag that satisfies predicate, or the result of invoking failure with no arguments if there is none."))
 ((name . "bag-count")
  (signature lambda ((procedure? predicate) (bag? bag)) integer?)
  (subsigs (predicate (lambda (obj) boolean?)))
  (tags pure)
  (desc . "Returns the number of elements of bag that satisfy predicate as an exact integer."))
 ((name . "bag-any?")
  (signature lambda ((procedure? predicate) (bag? bag)) boolean?)
  (subsigs (predicate (lambda (obj) boolean?)))
  (tags pure)
  (desc . "Returns #t if any element of bag satisfies predicate, or #f otherwise. Note that this differs from the SRFI 1 analogue because it does not return an element of the bag."))
 ((name . "bag-every?")
  (signature lambda ((procedure? predicate) (bag? bag)) boolean?)
  (subsigs (predicate (lambda (obj) boolean?)))
  (tags pure)
  (desc . "Returns #t if every element of bag satisfies predicate, or #f otherwise. Note that this differs from the SRFI 1 analogue because it does not return an element of the bag. "))
 ((name . "bag-map")
  (signature lambda ((comparator? comparator) (procedure? proc) (bag? bag)) *)
  (subsigs (proc (lambda (obj) *)))
  (tags pure)
  (desc . "Applies proc to each element of bag in arbitrary order and returns a newly allocated bag, created as if by (bag comparator), which contains the results of the applications. For example:
(bag-map string-ci-comparator symbol->string (bag eq? 'foo 'bar 'baz)) => (bag string-ci-comparator \"foo\" \"bar\" \"baz\")
Note that, when proc defines a mapping that is not 1:1, some of the mapped objects may be equivalent in the sense of comparator's equality predicate, and in this case duplicate elements are omitted as in the bag constructor."))
 ((name . "bag-for-each")
  (signature lambda ((procedure? proc) (bag? bag)) undefined)
  (subsigs (proc (lambda (obj) undefined)))
  (desc . "Applies proc to bag in arbitrary order, discarding the returned values. Returns an unspecified result."))
 ((name . "bag-fold")
  (signature lambda ((procedure? proc) nil (bag? bag)) *)
  (subsigs (proc (lambda (obj state) *)))
  (tags pure)
  (desc . "Invokes proc on each member of bag in arbitrary order, passing the result of the previous invocation as a second argument. For the first invocation, nil is used as the second argument. Returns the result of the last invocation, or nil if there was no invocation."))
 ((name . "bag-filter")
  (signature lambda ((procedure? predicate) (bag? bag)) bag?)
  (subsigs (predicate (lambda (obj) *)))
  (tags pure)
  (desc . "Returns a newly allocated bag with the same comparator as bag, containing just the elements of bag that satisfy predicate."))
 ((name . "bag-filter!")
  (signature lambda ((procedure? predicate) (bag? bag)) bag?)
  (subsigs (predicate (lambda (obj) *)))
  (desc . "A linear update procedure that returns a bag containing just the elements of bag that satisfy predicate."))
 ((name . "bag-remove")
  (signature lambda ((procedure? predicate) (bag? bag)) bag?)
  (subsigs (predicate (lambda (obj) *)))
  (tags pure)
  (desc . "Returns a newly allocated bag with the same comparator as bag, containing just the elements of bag that do not satisfy predicate."))
 ((name . "bag-remove!")
  (signature lambda ((procedure? predicate) (bag? bag)) bag?)
  (subsigs (predicate (lambda (obj) *)))
  (desc . "A linear update procedure that returns a bag containing just the elements of bag that do not satisfy predicate."))
 ((name . "bag-partition")
  (signature lambda ((procedure? predicate) (bag? bag)) (values bag? bag?))
  (subsigs (predicate (lambda (obj) *)))
  (tags pure)
  (desc . "Returns two values: a newly allocated bag with the same comparator as bag that contains just the elements of bag that satisfy predicate, and another newly allocated bag, also with the same comparator, that contains just the elements of bag that do not satisfy predicate."))
 ((name . "bag-partition!")
  (signature lambda ((procedure? predicate) (bag? bag)) (values bag? bag?))
  (subsigs (predicate (lambda (obj) *)))
  (desc . "A linear update procedure that returns two bags containing the elements of bag that do and do not, respectively, not satisfy predicate."))
 ((name . "bag-copy") 
  (signature lambda ((bag? bag)) bag?)
  (tags pure)
  (desc . "Returns a newly allocated bag containing the elements of bag, and using the same comparator."))
 ((name . "bag->list") 
  (signature lambda ((bag? bag)) list?)
  (desc . "Returns a newly allocated list containing the members of bag in unspecified order."))
 ((name . "list->bag")
  (signature lambda ((comparator? comparator) (list? list)) bag?)
  (tags pure)
  (desc . "Returns a newly allocated bag, created as if by bag using comparator, that contains the elements of list. Duplicate elements (in the sense of the equality predicate) are omitted."))
 ((name . "list->bag!") 
  (signature lambda ((bag? bag) (list? list)) bag?)
  (desc . "Returns a bag that contains the elements of both bag and list. Duplicate elements (in the sense of the equality predicate) are omitted."))
 ((name . "bag=?")
  (signature lambda ((bag? bag1) (bag? bag2) ...) boolean?)
  (tags pure)
  (desc . "Returns #t if each bag contains the same elements."))
 ((name . "bag<?")
  (signature lambda ((bag? bag1) (bag? bag2) ...) boolean?)
  (tags pure)
  (desc . "Returns #t if each bag other than the last is a proper subbag of the following bag, and #f otherwise."))
 ((name . "bag>?")
  (signature lambda ((bag? bag1) (bag? bag2) ...) boolean?)
  (tags pure)
  (desc . "Returns #t if each bag other than the last is a proper superbag of the following bag, and #f otherwise."))
 ((name . "bag<=?")
  (signature lambda ((bag? bag1) (bag? bag2) ...) boolean?)
  (tags pure)
  (desc . "Returns #t if each bag other than the last is a subbag of the following bag, and #f otherwise."))
 ((name . "bag>=?")
  (signature lambda ((bag? bag1) (bag? bag2) ...) boolean?)
  (tags pure)
  (desc . "Returns #t if each bag other than the last is a superbag of the following bag, and #f otherwise."))
 ((name . "bag-union")
  (signature lambda ((bag? bag1) (bag? bag2) ...) bag?)
  (tags pure)
  (desc . "Return a newly allocated bag that is the union of the bags."))
 ((name . "bag-intersection")
  (signature lambda ((bag? bag1) (bag? bag2) ...) bag?)
  (tags pure)
  (desc . "Return a newly allocated bag that is the intersection of the bags."))
 ((name . "bag-difference")
  (signature lambda ((bag? bag1) (bag? bag2) ...) bag?)
  (tags pure)
  (desc . "Return a newly allocated bag that is the asymmetric difference of the bags. Asymmetric difference is extended to more than two bags by taking the difference between the first bag and the union of the others."))
 ((name . "bag-xor")
  (signature lambda ((bag? bag1) (bag? bag2)) bag?)
  (tags pure)
  (desc . "Return a newly allocated bag that is the symmetric difference of the bags. Symmetric difference is not extended beyond two bags. Elements in the result bag are drawn from the first bag in which they appear."))
 ((name . "bag-union!")
  (signature lambda ((bag? bag1) (bag? bag2) ...) bag?)
  (desc . "Linear update returning a bag that is the union of the bags."))
 ((name . "bag-intersection!")
  (signature lambda ((bag? bag1) (bag? bag2) ...) bag?)
  (desc . "Linear update returning a bag that is the intersection of the bags."))
 ((name . "bag-difference!")
  (signature lambda ((bag? bag1) (bag? bag2) ...) bag?)
  (desc . "Linear update returning a bag that is the asymmetric difference of the bags. Asymmetric difference is extended to more than two bags by taking the difference between the first bag and the union of the others."))
 ((name . "bag-xor!")
  (signature lambda ((bag? bag1) (bag? bag2)) bag?)
  (desc . "Linear update returning a bag that is the symmetric difference of the bags. Symmetric difference is not extended beyond two bags. Elements in the result bag are drawn from the first bag in which they appear."))
 ((name . "bag-sum")
  (signature lambda ((bag? bag1) (bag? bag2) ...) bag?)
  (tags pure)
  (desc . "The bag-sum procedure returns a newly allocated bag containing all the unique elements in all the bags, such that the count of each unique element in the result is equal to the sum of the counts of that element in the arguments. It differs from bag-union by treating identical elements as potentially distinct rather than attempting to match them up."))
 ((name . "bag-sum!") 
  (signature lambda ((bag? bag1) (bag? bag2) ...) bag?)
  (desc . "Linear update returning a bag containing all the unique elements in all the bags, such that the count of each unique element in the result is equal to the sum of the counts of that element in the arguments. It differs from bag-union by treating identical elements as potentially distinct rather than attempting to match them up."))
 ((name . "bag-product")
  (signature lambda ((integer? n) (bag? bag)) bag?)
  (tags pure)
  (desc . "The bag-product procedure returns a newly allocated bag containing all the unique elements in bag, where the count of each unique element in the bag is equal to the count of that element in bag multiplied by n."))
 ((name . "bag-product!") 
  (signature lambda ((integer? n) (bag? bag)) bag?)
  (desc . "Linear update returning a bag containing all the unique elements in bag, where the count of each unique element in the bag is equal to the count of that element in bag multiplied by n."))
 ((name . "bag-unique-size")
  (signature lambda ((bag? bag)) integer?)
  (tags pure)
  (desc . "Returns the number of unique elements of bag."))
 ((name . "bag-element-count")
  (signature lambda ((bag? bag) element) integer?)
  (tags pure)
  (desc . "Returns an exact integer representing the number of times that element appears in bag."))
 ((name . "bag-for-each-unique")
  (signature lambda ((procedure? proc) (bag? bag)) undefined)
  (subsigs (proc (lambda (obj) undefined)))
  (desc . "Applies proc to each unique element of bag in arbitrary order, passing the element and the number of times it occurs in bag, and discarding the returned values. Returns an unspecified result."))
 ((name . "bag-fold-unique")
  (signature lambda ((procedure? proc) nil (bag? bag)) *)
  (subsigs (proc (lambda (obj state) *)))
  (tags pure)
  (desc . "Invokes proc on each unique element of bag in arbitrary order, passing the number of occurrences as a second argument and the result of the previous invocation as a third argument. For the first invocation, nil is used as the third argument. Returns the result of the last invocation."))
 ((name . "bag-increment!") 
  (signature lambda ((bag? bag) element count) bag?)
  (desc . "Linear update procedure that returns a bag with the same elements as bag, but with the element count of element in bag increased by the exact integer count (but not less than zero)."))
 ((name . "bag-decrement!")
  (signature lambda ((bag? bag) element count) bag?)
  (desc . "Linear update procedure that returns a bag with the same elements as bag, but with the element count of element in bag decreased by the exact integer count (but not less than zero)."))
 ((name . "bag->set") 
  (signature lambda ((bag? bag)) set?)
  (tags pure)
  (desc . "The bag->set procedure returns a newly allocated set containing the unique elements (in the sense of the equality predicate) of bag."))
 ((name . "set->bag")
  (signature lambda ((set? set)) bag?)
  (tags pure)
  (desc . "The set->bag procedure returns a newly allocated bag containing the elements of set."))
 ((name . "set->bag!") 
  (signature lambda ((set? set)) bag?)
  (desc . "The set->bag! procedure returns a bag containing the elements of both bag and set."))
 ((name . "bag->alist") 
  (signature lambda ((bag? bag)) list?)
  (desc . "The bag->alist procedure returns a newly allocated alist whose keys are the unique elements of bag and whose values are the number of occurrences of each element."))
 ((name . "alist->bag")
  (signature lambda ((comparator? comparator) (list? alist)) bag?)
  (tags pure)
  (desc . "The alist->bag returning a newly allocated bag based on comparator, where the keys of alist specify the elements and the corresponding values of alist specify how many times they occur."))
 ((name . "set-comparator") 
  (signature value comparator?)
  (desc . "Set comparator. The comparator does not provide comparison procedures, as there is no ordering between sets. It is an error to compare sets with different element comparators."))
 ((name . "bag-comparator")
  (signature value comparator?)
  (desc . "Bag comparator. The comparator does not provide comparison procedures, as there is no ordering between bags. It is an error to compare bags with different element comparators.")))
