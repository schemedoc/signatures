(((name . "mapping")
  (signature lambda ((comparator? comparator) arg ...) mapping?)
  (tags pure)
  (desc . "Returns a newly allocated mapping. The comparator argument is a SRFI 128 comparator, which is used to control and distinguish the keys of the mapping. The args alternate between keys and values and are used to initialize the mapping. In particular, the number of args has to be even. Earlier associations with equal keys take precedence over later arguments."))
 ((name . "mapping-unfold")
  (signature
   lambda
   ((procedure? stop?)
    (procedure? mapper)
    (procedure? successor)
    seed
    (comparator? comparator))
   mapping?)
  (subsigs
   (stop? (lambda (seed) boolean?))
   (mapper (lambda (seed) (values * *)))
   (successor (lambda (seed) *)))
  (tags pure)
  (desc . "Create a newly allocated mapping as if by mapping using comparator. If the result of applying the predicate stop? to seed is true, return the mapping. Otherwise, apply the procedure mapper to seed. Mapper returns two values which are added to the mapping as the key and the value, respectively. Then get a new seed by applying the procedure successor to seed, and repeat this algorithm. Associations earlier in the list take precedence over those that come later."))
 ((name . "mapping?") (signature lambda (obj) boolean?) (tags pure predicate) (desc . "Returns #t if obj is a mapping, and #f otherwise."))
 ((name . "mapping-contains?")
  (signature lambda ((mapping? mapping) key) boolean?)
  (tags pure)
  (desc . "Returns #t if key is the key of an association of mapping and #f otherwise."))
 ((name . "mapping-empty?")
  (signature lambda ((mapping? mapping)) boolean?)
  (tags pure)
  (desc . "Returns #t if mapping has no associations and #f otherwise."))
 ((name . "mapping-disjoint?")
  (signature lambda ((mapping? mapping1) (mapping? mapping2)) boolean?)
  (tags pure)
  (desc . "Returns #t if mapping1 and mapping2 have no keys in common and #f otherwise."))
 ((name . "mapping-ref")
  (signature
   case-lambda
   (((mapping? mapping) key) *)
   (((mapping? mapping) key (procedure? failure)) *)
   (((mapping? mapping) key (procedure? failure) (procedure? success)) *))
  (subsigs (failure (lambda () *)) (success (lambda (value) *)))
  (tags pure)
  (desc . "Extracts the value associated to key in the mapping mapping, invokes the procedure success in tail context on it, and returns its result; if success is not provided, then the value itself is returned. If key is not contained in mapping and failure is supplied, then failure is invoked in tail context on no arguments and its values are returned. Otherwise, it is an error."))
 ((name . "mapping-ref/default")
  (signature lambda ((mapping? mapping) key default) *)
  (tags pure)
  (desc . "Semantically equivalent to, but may be more efficient than, the following code:
(mapping-ref mapping key (lambda () default))"))
 ((name . "mapping-key-comparator")
  (signature lambda ((mapping? mapping)) comparator?)
  (tags pure)
  (desc . "Returns the comparator used to compare the keys of the mapping mapping."))
 ((name . "mapping-adjoin")
  (signature lambda ((mapping? mapping) key1 value1 ...) mapping?)
  (tags pure)
  (desc . "The mapping-adjoin procedure returns a newly allocated mapping that uses the same comparator as the mapping mapping and contains all the associations of mapping, and in addition new associations by processing the arguments from left to right. The args alternate between keys and values. Whenever there is a previous association for a key, the previous association prevails and the new association is skipped. It is an error to add an association to mapping whose key that does not return #t when passed to the type test procedure of the comparator."))
 ((name . "mapping-adjoin!")
  (signature lambda ((mapping? mapping) key1 value1 ...) mapping?)
  (desc . "The mapping-adjoin! procedure is the same as mapping-adjoin, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping."))
 ((name . "mapping-set")
  (signature lambda ((mapping? mapping) key1 value1 ...) mapping?)
  (tags pure)
  (desc . "The mapping-set procedure returns a newly allocated mapping that uses the same comparator as the mapping mapping and contains all the associations of mapping, and in addition new associations by processing the arguments from left to right. The args alternate between keys and values. Whenever there is a previous association for a key, it is deleted. It is an error to add an association to mapping whose key that does not return #t when passed to the type test procedure of the comparator."))
 ((name . "mapping-set!")
  (signature lambda ((mapping? mapping) key1 value1 ...) mapping?)
  (desc . "The mapping-set! procedure is the same as mapping-set, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping."))
 ((name . "mapping-replace")
  (signature lambda ((mapping? mapping) key value) mapping?)
  (tags pure)
  (desc . "The mapping-replace procedure returns a newly allocated mapping that uses the same comparator as the mapping mapping and contains all the associations of mapping except as follows: If key is equal (in the sense of mapping's comparator) to an existing key of mapping, then the association for that key is omitted and replaced the association defined by the pair key and value. If there is no such key in mapping, then mapping is returned unchanged."))
 ((name . "mapping-replace!")
  (signature lambda ((mapping? mapping) key value) mapping?)
  (desc . "The mapping-replace! procedure is the same as mapping-replace, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping."))
 ((group
    ((name . "mapping-delete")
     (signature lambda ((mapping? mapping) key ...) mapping?)
     (tags pure))
    ((name . "mapping-delete!")
     (signature lambda ((mapping? mapping) key ...) mapping?)
     (tags pure))
    ((name . "mapping-delete-all")
     (signature lambda ((mapping? mapping) (list? keys)) mapping?)
     (tags pure))
    ((name . "mapping-delete-all!")
     (signature lambda ((mapping? mapping) (list? keys)) mapping?)))
  (desc . "The mapping-delete procedure returns a newly allocated mapping containing all the associations of the mapping mapping except for any whose keys are equal (in the sense of mapping's comparator) to one or more of the keys. Any key that is not equal to some key of the mapping is ignored.
The mapping-delete! procedure is the same as mapping-delete, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.
The mapping-delete-all and mapping-delete-all! procedures are the same as mapping-delete and mapping-delete!, respectively, except that they accept a single argument which is a list of keys whose associations are to be deleted."))
 ((name . "mapping-intern")
  (signature
   lambda
   ((mapping? mapping) key (procedure? failure))
   (values mapping? *))
  (subsigs (failure (lambda () *)))
  (tags pure)
  (desc . "Extracts the value associated to key in the mapping mapping, and returns mapping and the value as two values. If key is not contained in mapping, failure is invoked on no arguments. The procedure then returns two values, a newly allocated mapping that uses the same comparator as the mapping and contains all the associations of mapping, and in addition a new association mapping key to the result of invoking failure, and the result of invoking failure."))
 ((name . "mapping-intern!")
  (signature
   lambda
   ((mapping? mapping) key (procedure? failure))
   (values mapping? *))
  (subsigs (failure (lambda () *)))
  (desc . "The mapping-intern! procedure is the same as mapping-intern, except that it is permitted to mutate and return the mapping argument as its first value rather than allocating a new mapping."))
 ((name . "mapping-update")
  (signature
   case-lambda
   (((mapping? mapping) key (procedure? updater)) mapping?)
   (((mapping? mapping) key (procedure? updater) (procedure? failure))
    mapping?)
   (((mapping? mapping)
     key
     (procedure? updater)
     (procedure? failure)
     (procedure? success))
    mapping?))
  (subsigs
   (updater (lambda (value) *))
   (failure (lambda () *))
   (success (lambda (value) *)))
  (tags pure)
  (desc . "Semantically equivalent to, but may be more efficient than, the following code
(mapping-set mapping key (updater (mapping-ref mapping key failure success)))"))
 ((name . "mapping-update!")
  (signature
   case-lambda
   (((mapping? mapping) key (procedure? updater)) mapping?)
   (((mapping? mapping) key (procedure? updater) (procedure? failure))
    mapping?)
   (((mapping? mapping)
     key
     (procedure? updater)
     (procedure? failure)
     (procedure? success))
    mapping?))
  (subsigs
   (updater (lambda (value) *))
   (failure (lambda () *))
   (success (lambda (value) *)))
  (desc . "The mapping-update! procedure is the same as mapping-update, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping. "))
 ((name . "mapping-update/default")
  (signature
   lambda
   ((mapping? mapping) key (procedure? updater) default)
   mapping?)
  (subsigs (updater (lambda (value) *)))
  (tags pure)
  (desc . "Semantically equivalent to, but may be more efficient than, the following code
(mapping-set mapping key (updater (mapping-ref/default mapping key default)))"))
 ((name . "mapping-update!/default")
  (signature
   lambda
   ((mapping? mapping) key (procedure? updater) default)
   mapping?)
  (subsigs (updater (lambda (value) *)))
  (desc . "The mapping-update!/default procedure is the same as mapping-update/default, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping."))
 ((name . "mapping-pop")
  (signature
   case-lambda
   (((mapping? mapping)) (values mapping? * *))
   (((mapping? mapping) (procedure? failure)) (values mapping? * *)))
  (subsigs (failure (lambda () (values mapping? * *))))
  (tags pure)
  (desc . "The mapping-pop procedure exported from (srfi 146) chooses the association with the least key from mapping and returns three values, a newly allocated mapping that uses the same comparator as mapping and contains all associations of mapping except the chosen one, and the key and the value of the chosen association. If mapping contains no association and failure is supplied, then failure is invoked in tail context on no arguments and its values returned. Otherwise, it is an error."))
 ((name . "mapping-pop!")
  (signature
   case-lambda
   (((mapping? mapping)) (values mapping? * *))
   (((mapping? mapping) (procedure? failure)) (values mapping? * *)))
  (subsigs (failure (lambda () (values mapping? * *))))
  (desc . "The mapping-pop! procedure is the same as mapping-pop, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping."))
 ((name . "mapping-search")
  (signature
   lambda
   ((mapping? mapping) key (procedure? failure) (procedure? success))
   (values mapping? *))
  (subsigs
   (failure (lambda ((procedure? insert) (procedure? ignore)) *))
   (insert (lambda (value obj) *))
   (ignore (lambda (obj) *))
   (success (lambda (key value (procedure? update) (procedure? remove)) *))
   (update (lambda (new-key new-value obj) *))
   (remove (lambda (obj) *)))
  (tags pure)
  (desc . "The mapping mapping is searched in order (that is in the order of the stored keys) for an association with key key. If it is not found, then the failure procedure is tail-called with two continuation arguments, insert and ignore, and is expected to tail-call one of them. If an association with key key is found, then the success procedure is tail-called with the matching key of mapping, the associated value, and two continuations, update and remove, and is expected to tail-call one of them.
It is an error if the continuation arguments are invoked, but not in tail position in the failure and success procedures. It is also an error if the failure and success procedures return to their implicit continuation without invoking one of their continuation arguments.
The effects of the continuations are as follows (where obj is any Scheme object):
* Invoking (insert value obj) causes a mapping to be newly allocated that uses the same comparator as the mapping mapping and contains all the associations of mapping, and in addition a new association mapping key to value.
* Invoking (ignore obj) has no effects; in particular, no new mapping is allocated (but see below).
* Invoking (update new-key new-value obj) causes a mapping to be newly allocated that uses the same comparator as the mapping and contains all the associations of mapping, except for the association with key key, which is replaced by a new association mapping new-key to new-value.
* Invoking (remove obj) causes a mapping to be newly allocated that uses the same comparator as the mapping and contains all the associations of mapping, except for the association with key key.

In all cases, two values are returned: the possibly newly allocated mapping and obj."))
 ((name . "mapping-search!")
  (signature
   lambda
   ((mapping? mapping) key (procedure? failure) (procedure? success))
   (values mapping? *))
  (subsigs (failure (lambda ((procedure? insert) (procedure? ignore)) *))
   (insert (lambda (value obj) *))
   (ignore (lambda (obj) *))
   (success (lambda (key value (procedure? update) (procedure? remove)) *))
   (update (lambda (new-key new-value obj) *))
   (remove (lambda (obj) *)))
  (desc . "The mapping-search! procedure is the same as mapping-search, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping."))
 ((name . "mapping-size")
  (signature lambda ((mapping? mapping)) integer?)
  (tags pure)
  (desc . "Returns the number of associations in mapping as an exact integer."))
 ((name . "mapping-find")
  (signature
   lambda
   ((procedure? predicate) (mapping? mapping) (procedure? failure))
   (values * *))
  (subsigs (predicate (lambda (key value) boolean?)) (failure (lambda () *)))
  (tags pure)
  (desc . "Returns the association with the least key of the mapping mapping consisting of a key and value as two values such that predicate returns a true value when invoked with key and value as arguments, or the result of tail-calling failure with no arguments if there is none. There are no guarantees how many times and with which keys and values predicate is invoked."))
 ((name . "mapping-count")
  (signature lambda ((procedure? predicate) (mapping? mapping)) integer?)
  (subsigs (predicate (lambda (key value) boolean?)))
  (tags pure)
  (desc . "Returns the number of associations of the mapping mapping that satisfy predicate (in the sense of mapping-find) as an exact integer. There are no guarantees how many times and with which keys and values predicate is invoked."))
 ((name . "mapping-any?")
  (signature lambda ((procedure? predicate) (mapping? mapping)) boolean?)
  (subsigs (predicate (lambda (key value) boolean?)))
  (tags pure)
  (desc . " Returns #t if any association of the mapping mapping satisfies predicate (in the sense of mapping-find), or #f otherwise. There are no guarantees how many times and with which keys and values predicate is invoked."))
 ((name . "mapping-every?")
  (signature lambda ((procedure? predicate) (mapping? mapping)) boolean?)
  (subsigs (predicate (lambda (key value) boolean?)))
  (tags pure)
  (desc . "Returns #t if every association of the mapping mapping satisfies predicate (in the sense of mapping-find), or #f otherwise. There are no guarantees how many times and with which keys and values predicate is invoked."))
 ((name . "mapping-keys")
  (signature lambda ((mapping? mapping)) list?)
  (tags pure)
  (desc . "Returns a newly allocated list of all the keys in increasing order in the mapping mapping."))
 ((name . "mapping-values")
  (signature lambda ((mapping? mapping)) list?)
  (tags pure)
  (desc . "Returns a newly allocated list of all the values in increasing order of the keys in the mapping mapping. "))
 ((name . "mapping-entries")
  (signature lambda ((mapping? mapping)) (values list? list?))
  (tags pure)
  (desc . "Returns two values, a newly allocated list of all the keys in the mapping mapping, and a newly allocated list of all the values in the mapping mapping in increasing order of the keys."))
 ((name . "mapping-map")
  (signature
   lambda
   ((procedure? proc) (comparator? comparator) (mapping? mapping))
   mapping?)
  (subsigs (proc (lambda (key value) (values * *))))
  (tags pure)
  (desc . "Applies proc, which returns two values, on two arguments, the key and value of each association of mapping in increasing order of the keys and returns a newly allocated mapping that uses the comparator comparator, and which contains the results of the applications inserted as keys and values.
Note that, when proc defines a mapping that is not 1:1 between the keys, some of the mapped objects may be equivalent in the sense of the comparator's equality predicate, and in this case duplicate associations are omitted as in the mapping constructor. It is unpredictable which one will be preserved in the result."))
 ((name . "mapping-for-each")
  (signature
   lambda
   ((procedure? proc) (comparator? comparator) (mapping? mapping))
   undefined)
  (subsigs (proc (lambda (key value) undefined)))
  (desc . "Invokes proc for every association in the mapping mapping in increasing order of the keys, discarding the returned values, with two arguments: the key of the association and the value of the association. Returns an unspecified value."))
 ((name . "mapping-fold")
  (signature lambda ((procedure? proc) nil (mapping? mapping)) *)
  (subsigs (proc (lambda (key value state) *)))
  (tags pure)
  (desc . "Invokes proc for each association of the mapping mapping in increasing order of the keys with three arguments: the key of the association, the value of the association, and an accumulated result of the previous invocation. For the first invocation, nil is used as the third argument. Returns the result of the last invocation, or nil if there was no invocation."))
 ((name . "mapping-map->list")
  (signature lambda ((procedure? proc) (mapping? mapping)) list?)
  (subsigs (proc (lambda (key value) *)))
  (tags pure)
  (desc . "Calls proc for every association in increasing order of the keys in the mapping mapping with two arguments: the key of the association and the value of the association. The values returned by the invocations of proc are accumulated into a list, which is returned."))
 ((name . "mapping-filter")
  (signature lambda ((procedure? predicate) (mapping? mapping)) mapping?)
  (subsigs (predicate (lambda (key value) boolean?)))
  (tags pure)
  (desc . "Returns a newly allocated mapping with the same comparator as the mapping mapping, containing just the associations of mapping that satisfy predicate (in the sense of mapping-find)."))
 ((name . "mapping-filter!")
  (signature lambda ((procedure? predicate) (mapping? mapping)) mapping?)
  (subsigs (predicate (lambda (key value) boolean?)))
  (desc . "A linear update procedure that returns a mapping containing just the associations of mapping that satisfy predicate."))
 ((name . "mapping-remove")
  (signature lambda ((procedure? predicate) (mapping? mapping)) mapping?)
  (subsigs (predicate (lambda (key value) boolean?)))
  (tags pure)
  (desc . "Returns a newly allocated mapping with the same comparator as the mapping mapping, containing just the associations of mapping that do not satisfy predicate (in the sense of mapping-find)."))
 ((name . "mapping-remove!")
  (signature lambda ((procedure? predicate) (mapping? mapping)) mapping?)
  (subsigs (predicate (lambda (key value) boolean?)))
  (desc . "A linear update procedure that returns a mapping containing just the associations of mapping that do not satisfy predicate."))
 ((name . "mapping-partition")
  (signature
   lambda
   ((procedure? predicate) (mapping? mapping))
   (values mapping? mapping?))
  (subsigs (predicate (lambda (key value) boolean?)))
  (tags pure)
  (desc . "Returns two values: a newly allocated mapping with the same comparator as the mapping mapping that contains just the associations of mapping that satisfy predicate (in the sense of mapping-find), and another newly allocated mapping, also with the same comparator, that contains just the associations of mapping that do not satisfy predicate."))
 ((name . "mapping-partition!")
  (signature
   lambda
   ((procedure? predicate) (mapping? mapping))
   (values mapping? mapping?))
  (subsigs (predicate (lambda (key value) boolean?)))
  (desc . "A linear update procedure that returns two mappings containing the associations of mapping that do and do not, respectively, satisfy predicate."))
 ((name . "mapping-copy")
  (signature lambda ((mapping? mapping)) mapping?)
  (tags pure)
  (desc . "Returns a newly allocated mapping containing the associations of the mapping mapping, and using the same comparator."))
 ((name . "mapping->alist")
  (signature lambda ((mapping? mapping)) list?)
  (tags pure)
  (desc . "Returns a newly allocated association list containing the associations of the mapping in increasing order of the keys. Each association in the list is a pair whose car is the key and whose cdr is the associated value."))
 ((name . "alist->mapping")
  (signature lambda ((comparator? comparator) (list? alist)) mapping?)
  (tags pure)
  (desc . "Returns a newly allocated mapping, created as if by mapping using the comparator comparator, that contains the associations in the list, which consist of a pair whose car is the key and whose cdr is the value. Associations earlier in the list take precedence over those that come later."))
 ((name . "alist->mapping!")
  (signature lambda ((mapping? mapping) (list? alist)) mapping?)
  (desc . "A linear update procedure that returns a mapping that contains the associations of both mapping and alist. Associations in the mapping and those earlier in the list take precedence over those that come later."))
 ((name . "mapping=?")
  (signature
   lambda
   ((comparator? comparator) (mapping? mapping1) (mapping? mapping2) ...)
   boolean?)
  (tags pure)
  (desc . "Returns #t if each mapping mapping contains the same associations, and #f otherwise.
Furthermore, it is explicitly not an error if mapping=? is invoked on mappings that do not share the same (key) comparator. In that case, #f is returned. "))
 ((name . "mapping<?")
  (signature
   lambda
   ((comparator? comparator) (mapping? mapping1) (mapping? mapping2) ...)
   boolean?)
  (tags pure)
  (desc . "Returns #t if the set of associations of each mapping mapping other than the last is a proper subset of the following mapping, and #f otherwise."))
 ((name . "mapping>?")
  (signature
   lambda
   ((comparator? comparator) (mapping? mapping1) (mapping? mapping2) ...)
   boolean?)
  (tags pure)
  (desc . "Returns #t if the set of associations of each mapping mapping other than the last is a proper superset of the following mapping, and #f otherwise."))
 ((name . "mapping<=?")
  (signature
   lambda
   ((comparator? comparator) (mapping? mapping1) (mapping? mapping2) ...)
   boolean?)
  (tags pure)
  (desc . "Returns #t if the set of associations of each mapping mapping other than the last is a subset of the following mapping, and #f otherwise."))
 ((name . "mapping>=?")
  (signature
   lambda
   ((comparator? comparator) (mapping? mapping1) (mapping? mapping2) ...)
   boolean?)
  (tags pure)
  (desc . "Returns #t if the set of associations of each mapping mapping other than the last is a superset of the following mapping, and #f otherwise."))
 ((group
    ((name . "mapping-union")
     (signature lambda ((mapping? mapping1) (mapping? mapping2) ...) mapping?)
     (tags pure))
    ((name . "mapping-intersection")
     (signature lambda ((mapping? mapping1) (mapping? mapping2) ...) mapping?)
     (tags pure))
    ((name . "mapping-difference")
     (signature lambda ((mapping? mapping1) (mapping? mapping2) ...) mapping?)
     (tags pure))
    ((name . "mapping-xor")
     (signature lambda ((mapping? mapping1) (mapping? mapping2)) mapping?)
     (tags pure)))
  (desc . "Return a newly allocated mapping whose set of associations is the union, intersection, asymmetric difference, or symmetric difference of the sets of associations of the mappings mappings. Asymmetric difference is extended to more than two mappings by taking the difference between the first mapping and the union of the others. Symmetric difference is not extended beyond two mappings. When comparing associations, only the keys are compared. In case of duplicate keys (in the sense of the mappings comparators), associations in the result mapping are drawn from the first mapping in which they appear."))
 ((group
    ((name . "mapping-union!")
     (signature lambda ((mapping? mapping1) (mapping? mapping2) ...) mapping?))
    ((name . "mapping-intersection!")
     (signature lambda ((mapping? mapping1) (mapping? mapping2) ...) mapping?))
    ((name . "mapping-difference!")
     (signature lambda ((mapping? mapping1) (mapping? mapping2) ...) mapping?))
    ((name . "mapping-xor!")
     (signature lambda ((mapping? mapping1) (mapping? mapping2)) mapping?)))
  (desc . "These procedures are the linear update analogs of the corresponding pure functional procedures above."))
 ((group
    ((name . "mapping/ordered")
     (signature lambda ((comparator? comparator) arg ...) mapping?)
     (tags pure))
    ((name . "mapping-unfold/ordered")
     (signature
       lambda
       ((procedure? stop?)
        (procedure? mapper)
        (procedure? successor)
        seed
        (comparator? comparator))
       mapping?)
     (subsigs
       (stop? (lambda (seed) boolean?))
       (mapper (lambda (seed) (values * *)))
       (successor (lambda (seed) *)))
     (tags pure)))
  (desc . "These are the same as mapping and mapping-unfold, except that it is an error if the keys are not in order, and they may be more efficient."))
 ((group
    ((name . "alist->mapping/ordered")
     (signature lambda ((comparator? comparator) (list? alist)) mapping?)
     (tags pure))
    ((name . "alist->mapping/ordered!")
     (signature lambda ((mapping? mapping) (list? alist)) mapping?)))
  (desc . "These are the same as alist->mapping and alist->mapping!, except that it is an error if the keys are not in order, and they may be more efficient."))
 ((group
    ((name . "mapping-min-key")
     (signature lambda ((mapping? mapping)) *)
     (tags pure))
    ((name . "mapping-max-key")
     (signature lambda ((mapping? mapping)) *)
     (tags pure)))
  (desc . "Returns the least/greatest key contained in the mapping mapping. It is an error for mapping to be empty."))
 ((group
    ((name . "mapping-min-value")
     (signature lambda ((mapping? mapping)) *)
     (tags pure))
    ((name . "mapping-max-value")
     (signature lambda ((mapping? mapping)) *)
     (tags pure)))
  (desc . "Returns the value associated with the least/greatest key contained in the mapping mapping. It is an error for mapping to be empty."))
 ((group
    ((name . "mapping-min-entry")
     (signature lambda ((mapping? mapping)) (values * *))
     (tags pure))
    ((name . "mapping-max-entry")
     (signature lambda ((mapping? mapping)) (values * *))
     (tags pure)))
  (desc . "Returns the entry associated with the least/greatest key contained in the mapping mapping as two values, the key and its associated value. It is an error for mapping to be empty."))
 ((group
    ((name . "mapping-key-predecessor")
     (signature lambda ((mapping? mapping) obj (procedure? failure)) *)
     (subsigs (failure (lambda () *)))
     (tags pure))
    ((name . "mapping-key-successor")
     (signature lambda ((mapping? mapping) obj (procedure? failure)) *)
     (subsigs (failure (lambda () *)))
     (tags pure)))
  (desc . "Returns the key contained in the mapping mapping that immediately precedes/succeeds obj in the mapping's order of keys. If no such key is contained in mapping (because obj is the minimum/maximum key, or because mapping is empty), returns the result of tail-calling the thunk failure."))
 ((group
    ((name . "mapping-range=")
     (signature lambda ((mapping? mapping) obj) mapping?)
     (tags pure))
    ((name . "mapping-range<")
     (signature lambda ((mapping? mapping) obj) mapping?)
     (tags pure))
    ((name . "mapping-range>")
     (signature lambda ((mapping? mapping) obj) mapping?)
     (tags pure))
    ((name . "mapping-range<=")
     (signature lambda ((mapping? mapping) obj) mapping?)
     (tags pure))
    ((name . "mapping-range>=")
     (signature lambda ((mapping? mapping) obj) mapping?)
     (tags pure)))
  (desc . "Returns a mapping containing only the associations of the mapping whose keys are equal to, less than, greater than, less than or equal to, or greater than or equal to obj."))
 ((group
    ((name . "mapping-range=!")
     (signature lambda ((mapping? mapping) obj) mapping?))
    ((name . "mapping-range<!")
     (signature lambda ((mapping? mapping) obj) mapping?))
    ((name . "mapping-range>!")
     (signature lambda ((mapping? mapping) obj) mapping?))
    ((name . "mapping-range<=!")
     (signature lambda ((mapping? mapping) obj) mapping?))
    ((name . "mapping-range>=!")
     (signature lambda ((mapping? mapping) obj) mapping?)))
  (desc . "Linear update procedures returning a mapping containing only the associations of the mapping whose keys are equal to, less than, greater than, less than or equal to, or greater than or equal to obj."))
 ((name . "mapping-split")
  (signature
   lambda
   ((mapping? mapping) obj)
   (values mapping? mapping? mapping? mapping? mapping?))
  (tags pure)
  (desc . "Returns five values, equivalent to the results of invoking (mapping-range< mapping obj), (mapping-range<= mapping obj), (mapping-range= mapping obj), (mapping-range>= mapping obj), and (mapping-range> mapping obj), but may be more efficient."))
 ((name . "mapping-split!")
  (signature
   lambda
   ((mapping? mapping) obj)
   (values mapping? mapping? mapping? mapping? mapping?))
  (desc . "The mapping-split! procedure is the same as mapping-split, except that it is permitted to mutate and return the mapping rather than allocating a new mapping."))
 ((name . "mapping-catenate")
  (signature
   lambda
   ((mapping? mapping1) key value (mapping? mapping2))
   mapping?)
  (tags pure)
  (desc . "Returns a newly allocated mapping using the comparator comparator whose set of associations is the union of the sets of associations of the mapping mapping1, the association mapping key to value, and the associations of mapping2. It is an error if the keys contained in mapping1 in their natural order, the key key, and the keys contained in mapping2 in their natural order (in that order) do not form a strictly monotone sequence with respect to the ordering of comparator."))
 ((name . "mapping-catenate!")
  (signature
   lambda
   ((mapping? mapping1) key value (mapping? mapping2))
   mapping?)
  (desc . "The mapping-catenate! procedure is the same as mapping-catenate, except that it is permitted to mutate and return one of the mappings rather than allocating a new mapping."))
 ((name . "mapping-map/monotone")
  (signature
   lambda
   ((procedure? proc) (comparator? comparator) (mapping? mapping))
   mapping?)
  (subsigs (proc (lambda (key value) (values * *))))
  (tags pure)
  (desc . "Equivalent to (mapping-map proc comparator mapping), but it is an error if proc does not induce a strictly monotone mapping between the keys with respect to the ordering of the comparator of mapping and the ordering of comparator. Maybe be implemented more efficiently than mapping-map."))
 ((name . "mapping-map/monotone!")
  (signature
   lambda
   ((procedure? proc) (comparator? comparator) (mapping? mapping))
   mapping?)
  (subsigs (proc (lambda (key value) (values * *))))
  (desc . "The mapping-map/monotone! procedure is the same as mapping-map/monotone, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping."))
 ((name . "mapping-fold/reverse")
  (signature lambda ((procedure? proc) nil (mapping? mapping)) *)
  (subsigs (proc (lambda (key value state) *)))
  (tags pure)
  (desc . "Equivalent to (mapping-fold proc nil mapping) except that the associations are processed in reverse order with respect to the natural ordering of the keys."))
 ((name . "comparator?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "Type predicate for comparators as exported by (srfi 128)."))
 ((name . "make-mapping-comparator")
  (signature lambda ((comparator? comparator)) comparator?)
  (tags pure)
  (desc . "Returns a comparator for mappings that is compatible with the equality predicate (mapping=? comparator mapping1 mapping2). It provides a (partial) ordering predicate that is applicable to pairs of mappings with the same (key) comparator. The lexicographic ordering with respect to the keys (and, in case a tiebreak is necessary, with respect to the ordering of the values) is used for mappings sharing a comparator. The existence of comparators returned by make-mapping-comparator allows mappings whose keys are mappings themselves, and it allows to compare mappings whose values are mappings."))
 ((name . "mapping-comparator")
  (signature value comparator?)
  (desc . "mapping-comparator is constructed by invoking make-mapping-comparator on (make-default-comparator).")))
