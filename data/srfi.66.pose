(((name . "u8vector?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "Returns #t if obj is an octect vector, otherwise returns #f. Analogous to vector?. "))
 ((name . "make-u8vector")
  (signature lambda ((integer? size) (integer? size)) u8vector?)
  (tags pure)
  (desc . "Returns a newly allocated octet vector of k elements. Each element is initialized to fill. Fill must be an octet. Analogous to make-vector."))
 ((name . "u8vector")
  (signature lambda ((integer? value) ...) u8vector?)
  (tags pure)
  (desc . "Returns a newly allocated octet vector whose elements contain the given arguments, which must all be octets. Analogous to vector."))
 ((name . "u8vector->list")
  (signature lambda ((u8vector? vec)) list?)
  (tags pure)
  (desc . "u8vector->listreturns a newly allocated list of the elements of u8vector in the same order.Analogous to vector->list."))
 ((name . "list->u8vector")
  (signature lambda ((list? proper-list)) u8vector?)
  (tags pure)
  (desc . "List->u8vector returns a newly allocated octet vector whose elements are the elements of list octets, which must all be octets. Analogous to list->vector."))
 ((name . "u8vector-length")
  (signature lambda ((u8vector? vec)) integer?)
  (tags pure)
  (desc . "Returns the number of elements in u8vector as an exact integer. Analogous to vector-length."))
 ((name . "u8vector-ref")
  (signature lambda ((u8vector? vec) (integer? i)) integer?)
  (tags pure)
  (desc . "k must be a valid index of u8vector. u8vector-ref returns the contents of element k of u8vector. Analogous to vector-ref."))
 ((name . "u8vector-set!")
  (signature lambda ((u8vector? vec) (integer? i) (integer? value)) undefined)
  (desc . "k must be a valid index of u8vector. u8vector-set! stores octet in element k of u8vector. The number of return values and the return values are unspecified. However, the number of return values is such that it is accepted by a continuation created by begin. Analogous to vector-set!."))
 ((name . "u8vector=?")
  (signature lambda ((u8vector? vec1) (u8vector? vec2)) boolean?)
  (tags pure)
  (desc . "Returns #t if u8vector-1 and u8vector-2 are equal---that is, if they have the same length and equal elements at all valid indices."))
 ((name . "u8vector-compare")
  (signature lambda ((u8vector? vec1) (u8vector? vec2)) integer?)
  (tags pure)
  (desc . "Compares u8vector-1 and u8vector-2 and returns a value consistent with the vector ordering specified in SRFI 67, i.e. -1 if u8vector-1 is smaller than u8vector-2, 0 if they are equal, and 1 if u8vector-1 is greater than u8vector-2. Shorter vectors are always smaller than longer ones, and vectors of equal length are compared lexicographically."))
 ((name . "u8vector-copy!")
  (signature
   lambda
   ((u8vector? source)
    (integer? source-start)
    (u8vector? target)
    (integer? target-start)
    (integer? n))
   undefined)
  (desc . "Copies data from octet vector source to octet vector target. Source-start, target-start, and n must be non-negative exact integers that satisfy
0 <= source-start <= source-start + n <= (u8vector-length source)
0 <= target-start <= target-start + n <= (u8vector-length target)

This copies the octets from source at indices [source-start, source-start + n) to consecutive indices in target starting at target-index.
This must work even if the memory regions for the source and the target overlap, i.e., the octets at the target location after the copy must be equal to the octets at the source location before the copy.
The number of return values and the return values are unspecified. However, the number of return values is such that it is accepted by a continuation created by begin. Analogous to vector-ref."))
 ((name . "u8vector-copy")
  (signature lambda ((u8vector? vec)) u8vector?)
  (tags pure)
  (desc . "Returns a newly allocated copy of octet vector u8vector.")))
