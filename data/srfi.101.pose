(((name . "pair?") (signature lambda (obj) boolean?) (tags pure predicate) (desc . "Returns #t if obj is a pair, and otherwise returns #f."))
 ((name . "cons") (signature lambda (obj1 obj2) pair?) (tags pure) (desc . "Returns a newly allocated pair whose car is obj1 and whose cdr is obj2. The pair is guaranteed to be different (in the sense of eqv?) from every existing object. This operation must take O(1) time."))
 ((name . "car") (signature lambda ((pair? pair)) *) (tags pure) (desc . "Returns the contents of the car field of pair. This operation must take O(1) time."))
 ((name . "cdr") (signature lambda ((pair? pair)) *) (tags pure) (desc . "Returns the contents of the cdr field of pair. This operation must take O(1) time."))
 ((group
    ((name . "caar") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "cadr") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "cdar") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "cddr") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "caaar") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "caadr") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "cadar") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "caddr") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "cdaar") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "cdadr") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "cddar") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "cdddr") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "caaaar") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "caaadr") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "caadar") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "caaddr") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "cadaar") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "cadadr") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "caddar") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "cadddr") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "cdaaar") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "cdaadr") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "cdadar") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "cdaddr") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "cddaar") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "cddadr") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "cdddar") (signature lambda ((pair? pair)) *) (tags pure))
    ((name . "cddddr") (signature lambda ((pair? pair)) *) (tags pure)))
  (desc . "These procedures are compositions of car and cdr."))
 ((name . "null?") (signature lambda (obj) boolean?) (tags pure) (desc . "Returns #t if obj is the empty list, #f otherwise."))
 ((name . "list?")
  (signature lambda (obj) boolean?)
  (tags pure predicate)
  (desc . "Returns #t if obj is a list, #f otherwise. By definition, all lists are chains of pairs that have finite length and are terminated by the empty list. This operation must take time bounded by O(log(n)), where n is the number of pairs in the chain forming the potential list."))
 ((name . "list") (signature lambda (obj ...) list?) (tags pure) (desc . "Returns a newly allocated list of its arguments. This operation must take time bounded by O(n), where n is the number of arguments to list."))
 ((name . "make-list")
  (signature case-lambda (((integer? k)) list?) (((integer? k) obj) list?))
  (tags pure)
  (desc . "Returns a newly allocated list of k elements. If a second argument is given, then each element is initialized to obj. Otherwise the initial contents of each element is unspecified. This operation must take time and space bounded by O(log(k))."))
 ((name . "length") (signature lambda ((list? list)) integer?) (tags pure) (desc . "Returns the length of list. This operation must take time bounded by O(log(n)), where n is the length of the list."))
 ((name . "length<=?")
  (signature lambda (obj (integer? k)) boolean?)
  (tags pure)
  (desc . "Returns true if obj is a chain of at least k pairs and false otherwise. This operation must take time bounded by O(log(min(k,n))), where n is the length of the chain of pairs."))
 ((name . "append")
  (signature
   case-lambda
   (((list? list) ...) list?)
   (((list? list) ... obj) *))
  (tags pure)
  (desc . "Returns a chain of pairs consisting of the elements of the first list followed by the elements of the other lists, with obj as the cdr of the final pair. An improper list results if obj is not a list. This operation must take time bounded by O(log(n)), where n is the total number of elements in the given lists."))
 ((name . "reverse") (signature lambda ((list? list)) list?) (tags pure) (desc . "Returns a newly allocated list consisting of the element of list in reverse order. This operation must take time bounded by O(n) where n is the length of the list."))
 ((name . "list-tail")
  (signature
   case-lambda
   (((list? list) (integer? k)) list?)
   ((obj (integer? k)) *))
  (tags pure)
  (desc . "Obj should be a chain of pairs with a count of at least k. The list-tail procedure returns the object obtained by omitting the first k elements in obj. This operation must take time bounded by O(log(min(k,n))), where n is the length of the chain of pairs."))
 ((name . "list-ref")
  (signature lambda ((pair? pair) (integer? k)) *)
  (tags pure)
  (desc . "Pair must be a chain of pairs whose count is at least k + 1. The list-ref procedure returns the kth element of pair. This operation must take time bounded by O(min(k,log(n))), where n is the length of the chain of pairs."))
 ((name . "list-set")
  (signature lambda ((pair? pair) (integer? k) obj) pair?)
  (tags pure)
  (desc . "Pair must be a chain of pairs whose count is at least k + 1. The list-set procedure returns the chain of pairs obtained by replacing the kth element with obj. This operation must take time bounded by O(min(k,log(n))), where n is the length of the chain of pairs."))
 ((name . "list-ref/update")
  (signature
   lambda
   ((pair? pair) (integer? k) (procedure? proc))
   (values * pair?))
  (subsigs (proc (lambda (obj) *)))
  (tags pure)
  (desc . "Returns the same results as:
(values (list-ref pair k) 
        (list-set pair k (proc (list-ref pair k))))

but it may be implemented more efficiently."))
 ((name . "map")
  (signature
   lambda
   ((procedure? proc) (list? list1) (list? list2) ...)
   list?)
  (subsigs (proc (lambda (obj1 obj2 ...) *)))
  (tags pure)
  (desc . "The lists should all have the same length. Proc should accept as many arguments as there are lists and return a single value.
The map procedure applies proc element-wise to the elements of the lists and returns a list of the results, in order. Proc is always called in the same dynamic environment as map itself. The order in which proc is applied to the elements of the lists is unspecified. "))
 ((name . "for-each")
  (signature
   lambda
   ((procedure? proc) (list? list1) (list? list2) ...)
   undefined)
  (subsigs (proc (lambda (obj1 obj2 ...) undefined)))
  (tags pure)
  (desc . "The lists should all have the same length. Proc should accept as many arguments as there are lists.
The for-each procedure applies proc element-wise to the elements of the lists for its side effects, in order from the first element to the last. Proc is always called in the same dynamic environment as for-each itself. The return values of for-each are unspecified."))
 ((group
    ((name . "random-access-list->linear-access-list") (signature lambda ((list? list)) list?) (tags pure))
    ((name . "linear-access-list->random-access-list") (signature lambda ((list? list)) list?) (tags pure)))
  (desc . "These procedures convert between (potentially) distinct representations of lists. To avoid confusion, parameters named ra-list range over lists represented with random-access lists, i.e. objects satisfying the list? predicate described above, while parameters named la-list range over lists represented with the more traditional linear-access lists, i.e. objects satisfying the list? predicate of R6RS. In systems that represent all lists as random-access lists, these conversions may simply be list identity procedures.")))
