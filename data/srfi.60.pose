(((group
    ((name . "logand")
     (signature lambda ((integer? n1) ...) integer?)
     (tags pure))
    ((name . "bitwise-and")
     (signature lambda ((integer? n1) ...) integer?)
     (tags pure)))
  (desc . "Returns the integer which is the bit-wise AND of the integer arguments."))
 ((group
    ((name . "logior")
     (signature lambda ((integer? n1) ...) integer?)
     (tags pure))
    ((name . "bitwise-ior")
     (signature lambda ((integer? n1) ...) integer?)
     (tags pure)))
  (desc . "Returns the integer which is the bit-wise OR of the integer arguments."))
 ((group
    ((name . "logxor")
     (signature lambda ((integer? n1) ...) integer?)
     (tags pure))
    ((name . "bitwise-xor")
     (signature lambda ((integer? n1) ...) integer?)
     (tags pure)))
  (desc . "Returns the integer which is the bit-wise XOR of the integer arguments."))
 ((group
    ((name . "lognot") (signature lambda ((integer? n)) integer?) (tags pure))
    ((name . "bitwise-not")
     (signature lambda ((integer? n)) integer?)
     (tags pure)))
  (desc . "Returns the integer which is the one's-complement of the integer argument."))
 ((group
    ((name . "bitwise-if")
     (signature lambda ((integer? mask) (integer? n0) (integer? n1)) integer?)
     (tags pure))
    ((name . "bitwise-merge")
     (signature lambda ((integer? mask) (integer? n0) (integer? n1)) integer?)
     (tags pure)))
  (desc . "Returns an integer composed of some bits from integer n0 and some from integer n1. A bit of the result is taken from n0 if the corresponding bit of integer mask is 1 and from n1 if that bit of mask is 0."))
 ((group
    ((name . "logtest")
     (signature lambda ((integer? j) (integer? k)) boolean?)
     (tags pure))
    ((name . "any-bits-set?")
     (signature lambda ((integer? j) (integer? k)) boolean?)
     (tags pure)))
  (desc . "(logtest j k) == (not (zero? (logand j k)))"))
 ((group
    ((name . "logcount") (signature lambda ((integer? n)) integer?) (tags pure))
    ((name . "bit-count") (signature lambda ((integer? n)) integer?) (tags pure)))
  (desc . "Returns the number of bits in integer n. If integer is positive, the 1-bits in its binary representation are counted. If negative, the 0-bits in its two's-complement binary representation are counted. If 0, 0 is returned."))
 ((name . "integer-length")
  (signature lambda ((integer? n)) integer?)
  (tags pure)
  (desc . "Returns the number of bits neccessary to represent n."))
 ((group
    ((name . "log2-binary-factors")
     (signature lambda ((integer? n)) integer?)
     (tags pure))
    ((name . "first-set-bit")
     (signature lambda ((integer? n)) integer?)
     (tags pure)))
  (desc . "Returns the number of factors of two of integer n. This value is also the bit-index of the least-significant `1' bit in n."))
 ((group
    ((name . "logbit?")
     (signature lambda ((integer? index) (integer? n)) boolean?)
     (tags pure))
    ((name . "bit-set?")
     (signature lambda ((integer? index) (integer? n)) boolean?)
     (tags pure)))
  (desc . "(logbit? index n) == (logtest (expt 2 index) n)"))
 ((name . "copy-bit")
  (signature lambda ((integer? index) (integer? from) (boolean? bit)) integer?)
  (tags pure)
  (desc . "Returns an integer the same as from except in the indexth bit, which is 1 if bit is #t and 0 if bit is #f."))
 ((name . "bit-field")
  (signature lambda ((integer? n) (integer? start) (integer? end)) integer?)
  (tags pure)
  (desc . "Returns the integer composed of the start (inclusive) through end (exclusive) bits of n. The startth bit becomes the 0-th bit in the result."))
 ((name . "copy-bit-field")
  (signature
   lambda
   ((integer? to) (integer? from) (integer? start) (integer? end))
   integer?)
  (tags pure)
  (desc . "Returns an integer the same as to except possibly in the start (inclusive) through end (exclusive) bits, which are the same as those of from. The 0-th bit of from becomes the startth bit of the result."))
 ((group
    ((name . "ash")
     (signature lambda ((integer? n) (integer? count)) integer?)
     (tags pure))
    ((name . "arithmetic-shift")
     (signature lambda ((integer? n) (integer? count)) integer?)
     (tags pure)))
  (desc . "Returns an integer equivalent to (inexact->exact (floor (* n (expt 2 count))))."))
 ((name . "rotate-bit-field")
  (signature
   lambda
   ((integer? n) (integer? count) (integer? start) (integer? end))
   integer?)
  (tags pure)
  (desc . "Returns n with the bit-field from start to end cyclically permuted by count bits towards high-order."))
 ((name . "reverse-bit-field")
  (signature lambda ((integer? n) (integer? start) (integer? end)) integer?)
  (tags pure)
  (desc . "Returns n with the order of bits start to end reversed."))
 ((name . "integer->list")
  (signature
   case-lambda
   (((integer? k)) list?)
   (((integer? k) (integer? len)) list?))
  (tags pure)
  (desc . "integer->list returns a list of len booleans corresponding to each bit of the non-negative integer k. #t is coded for each 1; #f for 0. The len argument defaults to (integer-length k)."))
 ((name . "list->integer")
  (signature lambda ((list? list)) integer?)
  (tags pure)
  (desc . "list->integer returns an integer formed from the booleans in the list list, which must be a list of booleans. A 1 bit is coded for each #t; a 0 bit for #f."))
 ((name . "booleans->integer")
  (signature lambda ((boolean? bool1) ...) integer?)
  (tags pure)
  (desc . "Returns the integer coded by the bool1 ... arguments.")))
