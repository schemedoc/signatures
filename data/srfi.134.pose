(((name . "ideque")
  (signature lambda (element ...) ideque?)
  (tags pure)
  (desc . "Returns an ideque containing the elements. The first element (if any) will be at the front of the ideque and the last element (if any) will be at the back. Takes O(n) time, where n is the number of elements."))
 ((name . "ideque-tabulate")
  (signature lambda ((integer? n) (procedure? proc)) ideque?)
  (subsigs (proc (lambda ((integer? k)) *)))
  (tags pure)
  (desc . "Invokes the predicate proc on every exact integer from 0 (inclusive) to n (exclusive). Returns an ideque containing the results in order of generation. Takes O(n) time."))
 ((name . "ideque-unfold")
  (signature
   lambda
   ((procedure? stop?) (procedure? mapper) (procedure? successor) seed)
   ideque?)
  (subsigs
   (stop? (lambda (seed) boolean?))
   (mapper (lambda (seed) *))
   (successor (lambda (seed) *)))
  (tags pure)
  (desc . "Invokes the predicate stop? on seed. If it returns false, generate the next result by applying mapper to seed, generate the next seed by applying successor to seed, and repeat this algorithm with the new seed. If stop? returns true, return an ideque containing the results in order of accumulation. Takes O(n) time."))
 ((name . "ideque-unfold-right")
  (signature
   lambda
   ((procedure? stop?) (procedure? mapper) (procedure? successor) seed)
   ideque?)
  (subsigs
   (stop? (lambda (seed) boolean?))
   (mapper (lambda (seed) *))
   (successor (lambda (seed) *)))
  (tags pure)
  (desc . "Invokes the predicate stop? on seed. If it returns false, generate the next result by applying mapper to seed, generate the next seed by applying successor to seed, and repeat the algorithm with the new seed. If stop? returns true, return an ideque containing the results in reverse order of accumulation. Takes O(n) time."))
 ((name . "ideque?")
  (signature lambda (x) boolean?)
  (tags pure predicate)
  (desc . "Returns #t if x is an ideque, and #f otherwise. Takes O(1) time."))
 ((name . "ideque-empty?")
  (signature lambda ((ideque? ideque)) boolean?)
  (tags pure)
  (desc . "Returns #t if ideque contains zero elements, and #f otherwise. Takes O(1) time."))
 ((name . "ideque=")
  (signature lambda ((procedure? elt=) (ideque? ideque) ...) boolean?)
  (subsigs (elt= (lambda (a b) boolean?)))
  (tags pure)
  (desc . "Determines ideque equality, given an element-equality procedure. Ideque A equals ideque B if they are of the same length, and their corresponding elements are equal, as determined by elt=. If the element-comparison procedure's first argument is from idequei, then its second argument is from idequei+1, i.e. it is always called as (elt= a b) for a an element of ideque A, and b an element of ideque B.
In the n-ary case, every idequei is compared to idequei+1 (as opposed, for example, to comparing ideque1 to every idequei, for i > 1). If there are zero or one ideque arguments, ideque= simply returns true. The name does not end in a question mark for compatibility with the SRFI-1 procedure list=.
Note that the dynamic order in which the elt= procedure is applied to pairs of elements is not specified. For example, if ideque= is applied to three ideques, A, B, and C, it may first completely compare A to B, then compare B to C, or it may compare the first elements of A and B, then the first elements of B and C, then the second elements of A and B, and so forth.
The equality procedure must be consistent with eq?. Note that this implies that two ideques which are eq? are always ideque=, as well; implementations may exploit this fact to \"short-cut\" the element-by-element comparisons."))
 ((name . "ideque-any")
  (signature lambda ((procedure? pred) (ideque? ideque)) *)
  (subsigs (pred (lambda (element) *)))
  (tags pure)
  (desc . "Invokes pred on the elements of the ideque in order until one call returns a true value, which is then returned. If there are no elements, returns #f. Takes O(n) time."))
 ((name . "ideque-every")
  (signature lambda ((procedure? pred) (ideque? ideque)) *)
  (subsigs (pred (lambda (element) *)))
  (tags pure)
  (desc . "Invokes pred on the elements of the ideque in order until one call returns a false value, which is then returned. If there are no elements, returns #t. Takes O(n) time."))
 ((name . "ideque-front")
  (signature lambda ((ideque? ideque)) *)
  (tags pure)
  (desc . "Returns the front element of ideque. It is an error for ideque to be empty. Takes O(1) time."))
 ((name . "ideque-back")
  (signature lambda ((ideque? ideque)) *)
  (tags pure)
  (desc . "Returns the back element of ideque. It is an error for ideque to be empty. Takes O(1) time."))
 ((name . "ideque-remove-front")
  (signature lambda ((ideque? ideque)) ideque?)
  (tags pure)
  (desc . "Returns an ideque with the front element of ideque removed. It is an error for ideque to be empty. Takes O(1) time."))
 ((name . "ideque-remove-back")
  (signature lambda ((ideque? ideque)) ideque?)
  (tags pure)
  (desc . "Returns an ideque with the back element of ideque removed. It is an error for ideque to be empty. Takes O(1) time."))
 ((name . "ideque-add-front")
  (signature lambda ((ideque? ideque) obj) ideque?)
  (tags pure)
  (desc . "Returns an ideque with obj pushed to the front of ideque. Takes O(1) time."))
 ((name . "ideque-add-back")
  (signature lambda ((ideque? ideque) obj) ideque?)
  (tags pure)
  (desc . "Returns an ideque with obj pushed to the back of ideque. Takes O(1) time."))
 ((name . "ideque-ref")
  (signature lambda ((ideque? ideque) (integer? n)) *)
  (tags pure)
  (desc . "Returns the nth element of ideque. It is an error unless n is less than the length of ideque. Takes O(n) time."))
 ((name . "ideque-take")
  (signature lambda ((ideque? ideque) (integer? n)) ideque?)
  (tags pure)
  (desc . "Returns an ideque containing the first n elements of ideque. It is an error if n is greater than the length of ideque. Takes O(n) time."))
 ((name . "ideque-take-right")
  (signature lambda ((ideque? ideque) (integer? n)) ideque?)
  (tags pure)
  (desc . "Returns an ideque containing the last n elements of ideque. It is an error if n is greater than the length of ideque. Takes O(n) time."))
 ((name . "ideque-drop")
  (signature lambda ((ideque? ideque) (integer? n)) ideque?)
  (tags pure)
  (desc . "Returns an ideque containing all but the first n elements of ideque. It is an error if n is greater than the length of ideque. Takes O(n) time."))
 ((name . "ideque-drop-right")
  (signature lambda ((ideque? ideque) (integer? n)) ideque?)
  (tags pure)
  (desc . "Returns an ideque containing all but the last n elements of ideque. It is an error if n is greater than the length of ideque. Takes O(n) time."))
 ((name . "ideque-split-at")
  (signature lambda ((ideque? ideque) (integer? n)) (values ideque? ideque?))
  (tags pure)
  (desc . "Returns two values, the results of (ideque-take ideque n) and (ideque-drop ideque n) respectively, but may be more efficient. Takes O(n) time."))
 ((name . "ideque-length")
  (signature lambda ((ideque? ideque)) integer?)
  (tags pure)
  (desc . "Returns the length of ideque as an exact integer. May take O(n) time, though O(1) is optimal."))
 ((name . "ideque-append")
  (signature lambda ((ideque? ideque) ...) ideque?)
  (tags pure)
  (desc . "Returns an ideque with the contents of the ideque followed by the others, or an empty ideque if there are none. Takes O(kn) time, where k is the number of ideques and n is the number of elements involved, though O(k log n) is possible."))
 ((name . "ideque-reverse")
  (signature lambda ((ideque? ideque)) ideque?)
  (tags pure)
  (desc . "Returns an ideque containing the elements of ideque in reverse order. Takes O(1) time."))
 ((name . "ideque-count")
  (signature lambda ((procedure? pred) (ideque? ideque)) integer?)
  (subsigs (pred (lambda (element) boolean?)))
  (tags pure)
  (desc . "Pred is a procedure taking a single value and returning a single value. It is applied element-wise to the elements of ideque, and a count is tallied of the number of elements that produce a true value. This count is returned. Takes O(n) time. The dynamic order of calls to pred is unspecified."))
 ((name . "ideque-zip")
  (signature lambda ((ideque? ideque1) (ideque? ideque2) ...) ideque?)
  (tags pure)
  (desc . "Returns an ideque of lists (not ideques) each of which contains the corresponding elements of ideques in the order specified. Terminates when all the elements of any of the ideques have been processed. Takes O(kn) time, where k is the number of ideques and n is the number of elements in the shortest ideque."))
 ((name . "ideque-map")
  (signature lambda ((procedure? proc) (ideque? ideque)) ideque?)
  (subsigs (proc (lambda (element) *)))
  (tags pure)
  (desc . "Applies proc to the elements of ideque and returns an ideque containing the results in order. The dynamic order of calls to proc is unspecified. Takes O(n) time."))
 ((name . "ideque-filter-map")
  (signature lambda ((procedure? proc) (ideque? ideque)) ideque?)
  (subsigs (proc (lambda (element) *)))
  (tags pure)
  (desc . "Applies proc to the elements of ideque and returns an ideque containing the true (i.e. non-#f) results in order. The dynamic order of calls to proc is unspecified. Takes O(n) time."))
 ((name . "ideque-for-each")
  (signature lambda ((procedure? proc) (ideque? ideque)) undefined)
  (subsigs (proc (lambda (element) undefined)))
  (desc . "Applies proc to the elements of ideque in forward order and returns an unspecified result. Takes O(n) time."))
 ((name . "ideque-for-each-right")
  (signature lambda ((procedure? proc) (ideque? ideque)) undefined)
  (subsigs (proc (lambda (element) undefined)))
  (desc . "Applies proc to the elements of ideque in reverse order and returns an unspecified result. Takes O(n) time."))
 ((name . "ideque-fold")
  (signature lambda ((procedure? proc) nil (ideque? ideque)) *)
  (subsigs (proc (lambda (element state) *)))
  (tags pure)
  (desc . "Invokes proc on the elements of ideque in forward order, passing the result of the previous invocation as a second argument. For the first invocation, nil is used as the second argument. Returns the result of the last invocation, or nil if there was no invocation. Takes O(n) time."))
 ((name . "ideque-fold-right")
  (signature lambda ((procedure? proc) nil (ideque? ideque)) *)
  (subsigs (proc (lambda (element state) *)))
  (tags pure)
  (desc . "Invokes proc on the elements of ideque in reverse order, passing the result of the previous invocation as a second argument. For the first invocation, nil is used as the second argument. Returns the result of the last invocation, or nil if there was no invocation. Takes O(n) time."))
 ((name . "ideque-append-map")
  (signature lambda ((procedure? proc) (ideque? ideque)) ideque?)
  (subsigs (proc (lambda (element) list?)))
  (tags pure)
  (desc . "Applies proc to the elements of ideque. It is an error if the result is not a list. Returns an ideque containing the elements of the lists in order. Takes O(n) time, where n is the number of elements in all the lists returned."))
 ((name . "ideque-filter")
  (signature lambda ((procedure? pred) (ideque? ideque)) ideque?)
  (subsigs (pred (lambda (element) boolean?)))
  (tags pure)
  (desc . "Returns an ideque containing the elements of ideque that do satisfy pred. Takes O(n) time."))
 ((name . "ideque-remove")
  (signature lambda ((procedure? pred) (ideque? ideque)) ideque?)
  (subsigs (pred (lambda (element) boolean?)))
  (tags pure)
  (desc . "Returns an ideque containing the elements of ideque that do not satisfy pred. Takes O(n) time."))
 ((name . "ideque-partition")
  (signature
   lambda
   ((procedure? pred) (ideque? ideque))
   (values ideque? ideque?))
  (subsigs (pred (lambda (element) boolean?)))
  (tags pure)
  (desc . "Returns two values, the results of (ideque-filter pred ideque) and (ideque-remove pred ideque) respectively, but may be more efficient. Takes O(n) time."))
 ((name . "ideque-find")
  (signature
   case-lambda
   (((procedure? pred) (ideque? ideque)) *)
   (((procedure? pred) (ideque? ideque) (procedure? failure)) *))
  (subsigs (pred (lambda (element) boolean?)) (failure (lambda () *)))
  (tags pure)
  (desc . "Returns the first element of ideque that satisfies pred. If there is no such element, returns the result of invoking the thunk failure; the default thunk is (lambda () #f). Takes O(n) time."))
 ((name . "ideque-find-right")
  (signature
   case-lambda
   (((procedure? pred) (ideque? ideque)) *)
   (((procedure? pred) (ideque? ideque) (procedure? failure)) *))
  (subsigs (pred (lambda (element) boolean?)) (failure (lambda () *)))
  (tags pure)
  (desc . "Returns the last element of ideque that satisfies pred. If there is no such element, returns the result of invoking the thunk failure; the default thunk is (lambda () #f). Takes O(n) time."))
 ((name . "ideque-take-while")
  (signature lambda ((procedure? pred) (ideque? ideque)) ideque?)
  (subsigs (pred (lambda (element) boolean?)))
  (tags pure)
  (desc . "Returns an ideque containing the longest initial prefix of elements in ideque all of which satisfy pred. Takes O(n) time."))
 ((name . "ideque-take-while-right")
  (signature lambda ((procedure? pred) (ideque? ideque)) ideque?)
  (subsigs (pred (lambda (element) boolean?)))
  (tags pure)
  (desc . "Returns an ideque containing the longest final prefix of elements in ideque all of which satisfy pred. Takes O(n) time."))
 ((name . "ideque-drop-while")
  (signature lambda ((procedure? pred) (ideque? ideque)) ideque?)
  (subsigs (pred (lambda (element) boolean?)))
  (tags pure)
  (desc . "Returns an ideque which omits the longest initial prefix of elements in ideque all of which satisfy pred, but includes all other elements of ideque. Takes O(n) time."))
 ((name . "ideque-drop-while-right")
  (signature lambda ((procedure? pred) (ideque? ideque)) ideque?)
  (subsigs (pred (lambda (element) boolean?)))
  (tags pure)
  (desc . "Returns an ideque which omits the longest final prefix of elements in ideque all of which satisfy pred, but includes all other elements of ideque. Takes O(n) time."))
 ((name . "ideque-span")
  (signature
   lambda
   ((procedure? pred) (ideque? ideque))
   (values ideque? ideque?))
  (subsigs (pred (lambda (element) boolean?)))
  (tags pure)
  (desc . "Returns two values, the initial prefix of the elements of ideque which do satisfy pred, and the remaining elements. Takes O(n) time."))
 ((name . "ideque-break")
  (signature
   lambda
   ((procedure? pred) (ideque? ideque))
   (values ideque? ideque?))
  (subsigs (pred (lambda (element) boolean?)))
  (tags pure)
  (desc . "Returns two values, the initial prefix of the elements of ideque which do not satisfy pred, and the remaining elements. Takes O(n) time."))
 ((name . "list->ideque")
  (signature lambda ((list? list)) ideque?)
  (tags pure)
  (desc . "(shared description for list->ideque, ideque->list) Conversion between ideque and list structures. FIFO order is preserved, so the front of a list corresponds to the front of an ideque. Each operation takes O(n) time."))
 ((name . "ideque->list")
  (signature lambda ((ideque? ideque)) list?)
  (tags pure)
  (desc . "(shared description for list->ideque, ideque->list) Conversion between ideque and list structures. FIFO order is preserved, so the front of a list corresponds to the front of an ideque. Each operation takes O(n) time."))
 ((name . "generator->ideque")
  (signature lambda ((procedure? generator)) ideque?)
  (subsigs (generator (lambda () *)))
  (desc . "(shared description for generator->ideque, ideque->generator) Conversion between SRFI 121 generators and ideques. Each operation takes O(n) time. A generator is a procedure that is called repeatedly with no arguments to generate consecutive values, and returns an end-of-file object when it has no more values to return."))
 ((name . "ideque->generator")
  (signature lambda ((ideque? ideque)) procedure?)
  (subsigs (return (lambda () *)))
  (desc . "(shared description for generator->ideque, ideque->generator) Conversion between SRFI 121 generators and ideques. Each operation takes O(n) time. A generator is a procedure that is called repeatedly with no arguments to generate consecutive values, and returns an end-of-file object when it has no more values to return.")))
